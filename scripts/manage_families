#!/usr/bin/env ruby
# frozen_string_literal: true

# =============================================================================
# scripts/manage_families â€” interactive TUI for managing project families
#
# Usage:
#   bundle exec ruby scripts/manage_families [OPTIONS]
#
# Run with --help for full usage.
# =============================================================================

require 'yaml'
require 'table_tennis'
require 'tty-prompt'

class FamilyManager
  PROJECTS_FILE     = File.expand_path('../src/_data/projects.yml',     __dir__)
  PROJECTS_DEV_FILE = File.expand_path('../src/_data/projects_dev.yml', __dir__)
  FAMILIES_FILE     = File.expand_path('../src/_data/families.yml',     __dir__)

  # All theme values that mean "deliberately not a family member"
  NON_FAMILY_THEMES = %w[adopt-me update-me avoid-me holiday].freeze

  # Fields synced to projects_dev.yml for family members
  FAMILY_FIELDS = %w[theme family_id family_position family_primary].freeze

  def initialize(file: PROJECTS_FILE, dev_file: PROJECTS_DEV_FILE,
                 families_file: FAMILIES_FILE,
                 auto_confirm: false, dry_run: false, color: $stdout.tty?)
    @file          = file
    @dev_file      = dev_file
    @families_file = families_file
    @auto_confirm  = auto_confirm
    @dry_run       = dry_run
    @color         = color
    @prompt        = TTY::Prompt.new(enable_color: color)

    load!
  end

  # ============================================================================
  # Top-level entry point
  # ============================================================================

  def run
    loop do
      puts ""
      unassigned = unassigned_projects

      choices = @families.map do |fam|
        count   = family_members(fam['id']).size
        label   = "#{fam['position'].to_s.rjust(2)}. #{fam['name'].ljust(32)} (#{count} members)"
        { name: label, value: fam['id'] }
      end
      choices << { name: "â”€" * 55, value: :separator, disabled: "" }
      choices << { name: "U  Unassigned projects (#{unassigned.size})", value: :unassigned }
      choices << { name: "N  Create a new family",                       value: :new_family }
      choices << { name: "Q  Save and exit",                             value: :quit }

      selection = @prompt.select(
        "ðŸ  Family Manager â€” select a family to manage:",
        choices,
        per_page: choices.size,
        filter:   true,
        cycle:    true,
      )

      case selection
      when :quit      then break
      when :unassigned then manage_unassigned
      when :new_family then create_family
      else manage_family(selection)
      end
    end

    save_all
    puts "\nâœ… Done."
  end

  # ============================================================================
  # Manage a single family
  # ============================================================================

  def manage_family(fid)
    loop do
      fam     = @families.find { |f| f['id'] == fid }
      members = family_members(fid)
      puts ""

      puts tt(
        members.map do |p|
          { pos: p['family_position'], name: p['name'], role: p['role'], stars: p['github_stars'],
            primary: p['family_primary'] ? 'â˜…' : '' }
        end,
        title:        "ðŸ“¦ #{fam['name']} (#{fid})  â€”  slot #{fam['position']}",
        columns:      %i[pos name role stars primary],
        headers:      { pos: 'Pos', name: 'Project', role: 'Role', stars: 'â­', primary: '' },
        color_scales: :stars,
      )

      action = @prompt.expand("Action for '#{fam['name']}'?") do |q|
        q.choice key: 'r', name: 'Reorder members within this family',        value: :reorder
        q.choice key: 'm', name: 'Remove a member from this family',          value: :move
        q.choice key: 'a', name: 'Add an unassigned project to this family',  value: :add
        q.choice key: 'p', name: 'Reposition this family among all families', value: :position
        q.choice key: 'd', name: 'Delete this family',                        value: :delete
        q.choice key: 'b', name: 'Back to main menu',                         value: :back
      end

      case action
      when :reorder  then reorder_members(fid)
      when :move     then move_member(fid)
      when :add      then add_unassigned_to_family(fid)
      when :position then reposition_family(fid)
      when :delete   then break if delete_family(fid)
      when :back     then break
      end
    end
  end

  # ============================================================================
  # Reposition a family in the global order â€” edits families.yml positions only
  # ============================================================================

  def reposition_family(fid)
    fam         = @families.find { |f| f['id'] == fid }
    current_pos = fam['position']

    choices = @families.map do |f|
      marker = f['id'] == fid ? ' â—€ current' : ''
      { name: "#{f['position'].to_s.rjust(2)}. #{f['name']}#{marker}", value: f['position'] }
    end

    target = @prompt.select(
      "Move '#{fam['name']}' to which position? (current = #{current_pos})",
      choices,
      default: current_pos,
      per_page: @families.size,
      cycle:    true,
    )

    if target == current_pos
      @prompt.warn "Already at position #{current_pos}. No change."
      return
    end

    ordered = @families.reject { |f| f['id'] == fid }
    ordered.insert(target - 1, fam)
    ordered.each_with_index { |f, i| f['position'] = i + 1 }

    @prompt.ok "Moved '#{fam['name']}' to position #{fam['position']}. Will be saved on exit."
  end

  # ============================================================================
  # Reorder members within a family
  #
  # Pick a member to move, pick its target position. family_position values
  # are updated for all members so the chosen member lands at the target slot
  # and everything else shifts accordingly. Renumbers 1..N after each move.
  # The list re-renders after every move so you can keep reordering until done.
  # ============================================================================

  def reorder_members(fid)
    loop do
      members = family_members(fid)
      return @prompt.warn("Need at least 2 members to reorder.") if members.size < 2

      move_choices = members.map.with_index(1) do |p, i|
        { name: "#{i.to_s.rjust(2)}. #{p['name']}", value: p }
      end
      move_choices << { name: 'â”€' * 40, value: :separator, disabled: '' }
      move_choices << { name: '(done reordering)', value: :done }

      subject = @prompt.select(
        "Move which member?",
        move_choices,
        per_page: move_choices.size,
        cycle:    true,
      )
      break if subject == :done

      current_idx = members.index(subject) # 0-based

      target_choices = members.each_index.reject { |i| i == current_idx }.map do |i|
        label = if i < current_idx
          "#{(i + 1).to_s.rjust(2)}. before #{members[i]['name']}"
        else
          "#{(i + 1).to_s.rjust(2)}. after  #{members[i]['name']}"
        end
        { name: label, value: i }
      end

      target_idx = @prompt.select(
        "Move '#{subject['name']}' to which position?",
        target_choices,
        per_page: target_choices.size,
        cycle:    true,
      )

      # Build the new ordered list and assign family_position 1..N
      reordered = members.reject { |p| p.equal?(subject) }
      reordered.insert(target_idx, subject)
      reordered.each_with_index { |p, i| p['family_position'] = i + 1 }

      @prompt.ok "Moved '#{subject['name']}' to position #{target_idx + 1}."
    end
  end

  # ============================================================================
  # Remove a member from the family (becomes unassigned)
  # ============================================================================

  def move_member(fid)
    members = family_members(fid)
    choices = members.map { |p| { name: p['name'], value: p } }
    choices << { name: 'â”€' * 40, value: :separator, disabled: '' }
    choices << { name: '(cancel)', value: nil }

    project = @prompt.select("Remove which member from this family?", choices,
                             per_page: choices.size, cycle: true)
    return unless project

    if @prompt.yes?("Remove '#{project['name']}' from family '#{fid}'?", default: false)
      project.delete('theme')
      project.delete('family_id')
      project.delete('family_position')
      project.delete('family_primary')
      @prompt.ok "'#{project['name']}' is now unassigned."
    end
  end

  # ============================================================================
  # Add an unassigned project to this family
  # ============================================================================

  def add_unassigned_to_family(fid)
    unassigned = unassigned_projects
    if unassigned.empty?
      @prompt.ok "No unassigned projects available."
      return
    end

    fam   = @families.find { |f| f['id'] == fid }
    fname = fam['name']

    choices = unassigned.map do |p|
      label = "#{p['name']}  [#{p['language']}  #{p['ecosystem']}]"
      label += "  â­#{p['github_stars']}" if p['github_stars'].to_i > 0
      { name: label, value: p }
    end
    choices << { name: 'â”€' * 40, value: :separator, disabled: '' }
    choices << { name: '(cancel)', value: nil }

    project = @prompt.select("Add which project to '#{fname}'?", choices,
                             per_page: [choices.size, 12].min, filter: true, cycle: true)
    return unless project

    project['theme']          = 'family'
    project['family_id']      = fid
    project['family_position'] = (family_members(fid).map { |p| p['family_position'] || 0 }.max || 0) + 1

    if @prompt.yes?("Mark '#{project['name']}' as family primary (shown first in stack)?", default: false)
      project['family_primary'] = true
    end

    @prompt.ok "Added '#{project['name']}' to '#{fname}'."
  end

  # ============================================================================
  # Manage unassigned projects
  # ============================================================================

  def manage_unassigned
    loop do
      unassigned = unassigned_projects
      if unassigned.empty?
        @prompt.ok "No unassigned projects."
        break
      end

      choices = unassigned.map.with_index(1) do |p, i|
        label = "#{i}. #{p['name'].ljust(40)} [#{p['language']}  #{p['ecosystem']}]"
        { name: label, value: p }
      end
      choices << { name: 'â”€' * 60, value: :separator, disabled: "" }
      choices << { name: 'Back to main menu', value: :back }

      selection = @prompt.select(
        "ðŸ“‹ Unassigned Projects (#{unassigned.size}) â€” select to assign:",
        choices,
        per_page: [choices.size, 12].min,
        filter:   true,
        cycle:    true,
      )

      break if selection == :back

      assign_project_to_family(selection)
    end
  end

  # ============================================================================
  # Assign a single project to a family (or create a new one)
  # ============================================================================

  def assign_project_to_family(project)
    choices = @families.map do |fam|
      count = family_members(fam['id']).size
      label = "#{fam['position'].to_s.rjust(2)}. #{fam['name'].ljust(32)} (#{count} members)"
      { name: label, value: fam['id'] }
    end
    choices << { name: 'â”€' * 55, value: :separator, disabled: "" }
    choices << { name: 'N  Create a new family', value: :new_family }
    choices << { name: 'B  Cancel',              value: :back }

    selection = @prompt.select(
      "Assign '#{project['name']}' to which family?",
      choices,
      per_page: choices.size,
      filter:   true,
      cycle:    true,
    )

    return if selection == :back

    fid = if selection == :new_family
      meta = prompt_new_family_meta
      return unless meta
      meta[:id]
    else
      selection
    end

    project['theme']           = 'family'
    project['family_id']       = fid
    project['family_position'] = (family_members(fid).map { |p| p['family_position'] || 0 }.max || 0) + 1

    if @prompt.yes?("Mark '#{project['name']}' as family primary?", default: false)
      project['family_primary'] = true
    end

    fname = @families.find { |f| f['id'] == fid }&.dig('name') || fid
    @prompt.ok "Assigned '#{project['name']}' â†’ '#{fname}'."
  end

  # ============================================================================
  # Create a new family (adds to families.yml, optionally seeds members)
  # ============================================================================

  def create_family
    puts "\nâ”â”â” Create New Family â”â”â”"
    meta = prompt_new_family_meta
    return unless meta

    fid   = meta[:id]
    fname = meta[:name]

    puts "\n  Now seed initial members (optional â€” you can add more later)."

    loop do
      available = unassigned_projects.reject { |p| p['family_id'] == fid }
      break if available.empty?

      choices = available.map do |p|
        { name: "#{p['name']}  [#{p['language']}]", value: p }
      end
      choices << { name: 'â”€' * 40, value: :separator, disabled: '' }
      choices << { name: '(done â€” finish seeding)', value: nil }

      project = @prompt.select(
        "Add a project to '#{fname}' (or choose done):",
        choices,
        per_page: [choices.size, 12].min,
        filter:   true,
        cycle:    true,
      )
      break unless project

      project['theme']           = 'family'
      project['family_id']       = fid
      project['family_position'] = (family_members(fid).map { |p| p['family_position'] || 0 }.max || 0) + 1

      if family_members(fid).size == 1 && @prompt.yes?("Mark as family primary?", default: true)
        project['family_primary'] = true
      end

      @prompt.ok "Added '#{project['name']}' to '#{fname}'."
    end

    @prompt.ok "Family '#{fname}' ready with #{family_members(fid).size} member(s)."
  end

  # ============================================================================
  # Delete a family (unassigns all members, removes from families.yml)
  # ============================================================================

  def delete_family(fid)
    fam     = @families.find { |f| f['id'] == fid }
    fname   = fam['name']
    members = family_members(fid)

    puts "  âš ï¸  This will UNASSIGN all #{members.size} member(s) from '#{fname}' and remove the family."
    return false unless @prompt.yes?("Delete family '#{fid}' and unassign all members?", default: false)

    members.each do |p|
      p.delete('theme')
      p.delete('family_id')
      p.delete('family_position')
      p.delete('family_primary')
    end

    @families.delete(fam)
    @families.each_with_index { |f, i| f['position'] = i + 1 }

    @prompt.ok "Family '#{fname}' deleted. #{members.size} project(s) are now unassigned."
    true
  end

  # ============================================================================
  private
  # ============================================================================

  def load!
    @projects = YAML.load_file(@file) || []
    @families = (YAML.load_file(@families_file) || []).sort_by { |f| f['position'] || 999 }
  end

  def family_members(fid)
    @projects
      .select { |p| p.is_a?(Hash) && p['family_id'] == fid }
      .sort_by { |p| p['family_position'] || 999 }
  end

  def unassigned_projects
    @projects.select do |p|
      p.is_a?(Hash) &&
        p['theme'] != 'family' &&
        !NON_FAMILY_THEMES.include?(p['theme'])
    end.sort_by { |p| p['name'] }
  end

  def prompt_new_family_meta
    fid = @prompt.ask("Family ID (kebab-case, e.g. 'my-new-family'):") do |q|
      q.required true
      q.modify   :strip
      q.validate(/\A[a-z0-9]+(?:-[a-z0-9]+)*\Z/, "Must be kebab-case (lowercase letters, numbers, hyphens)")
    end
    return nil unless fid

    if @families.any? { |f| f['id'] == fid }
      @prompt.error "Family '#{fid}' already exists."
      return nil
    end

    fname = @prompt.ask("Family display name (e.g. 'My New Family'):") do |q|
      q.required true
      q.modify   :strip
    end
    return nil unless fname

    next_pos = (@families.map { |f| f['position'] }.max || 0) + 1
    @families << { 'id' => fid, 'name' => fname, 'position' => next_pos }
    @prompt.ok "Family '#{fname}' added at position #{next_pos}."

    { id: fid, name: fname }
  end

  def save_all
    save_projects(@file, @projects)
    save_dev_file(@dev_file) if File.exist?(@dev_file)
    save_families(@families_file, @families)
  end

  def save_projects(path, data)
    if @dry_run
      @prompt.warn "DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(data))
    @prompt.ok "Saved: #{path}"
  end

  def save_dev_file(path)
    dev_data = YAML.load_file(path) || []
    name_map = @projects.each_with_object({}) { |p, h| h[p['name']] = p if p.is_a?(Hash) && p['name'] }
    dev_data.each do |dp|
      next unless dp.is_a?(Hash) && dp['name'] && name_map.key?(dp['name'])
      src = name_map[dp['name']]
      FAMILY_FIELDS.each { |f| dp[f] = src[f] }
      dp.delete('family_primary') unless src['family_primary']
    end

    if @dry_run
      @prompt.warn "DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(dev_data))
    @prompt.ok "Saved: #{path}"
  end

  def save_families(path, data)
    if @dry_run
      @prompt.warn "DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(data))
    @prompt.ok "Saved: #{path}"
  end

  def tt(rows, **opts)
    opts[:theme] = :ansi unless @color
    TableTennis.new(rows, opts).to_s
  end
end

# =============================================================================
# CLI
# =============================================================================

if __FILE__ == $0
  require 'optparse'

  options = {
    file:          FamilyManager::PROJECTS_FILE,
    dev_file:      FamilyManager::PROJECTS_DEV_FILE,
    families_file: FamilyManager::FAMILIES_FILE,
    auto_confirm:  false,
    dry_run:       false,
    color:         $stdout.tty?,
  }

  OptionParser.new do |op|
    op.banner = "Usage: bundle exec ruby scripts/manage_families [OPTIONS]"

    op.separator ""
    op.separator "Interactive TUI for managing project families."
    op.separator ""
    op.separator "Family metadata (name, global display order) lives in families.yml."
    op.separator "Project entries in projects.yml carry: theme, family_id, family_position, family_primary."
    op.separator "Within-family member order is determined by each project's family_position value."
    op.separator ""
    op.separator "From the main menu:"
    op.separator "  â€¢ Select a family by scrolling/filtering to manage its members"
    op.separator "  â€¢ [U] Manage unassigned projects"
    op.separator "  â€¢ [N] Create a new family"
    op.separator "  â€¢ [Q] Save and exit"
    op.separator ""
    op.separator "Per-family actions (via expand menu):"
    op.separator "  [r] Reorder members within the family (pick member, pick destination, repeat)"
    op.separator "  [m] Remove a member from the family"
    op.separator "  [a] Add an unassigned project to the family"
    op.separator "  [p] Reposition this family among all families"
    op.separator "  [d] Delete the family (unassigns all members)"
    op.separator "  [b] Back to main menu"
    op.separator ""
    op.separator "Changes are written to projects.yml, projects_dev.yml, and families.yml on exit."
    op.separator ""
    op.separator "Options:"

    op.on("--dry-run", "Preview saves without writing files") do
      options[:dry_run] = true
    end

    op.on("--no-color", "Disable ANSI colour output") do
      options[:color] = false
    end

    op.on("--file PATH", "Use a different projects YAML file") do |path|
      options[:file] = path
    end

    op.on("--dev-file PATH", "Use a different projects_dev YAML file") do |path|
      options[:dev_file] = path
    end

    op.on("--families-file PATH", "Use a different families YAML file") do |path|
      options[:families_file] = path
    end

    op.on("-h", "--help", "Show this help") do
      puts op
      exit 0
    end
  end.parse!

  FamilyManager.new(**options).run
end
