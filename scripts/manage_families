#!/usr/bin/env ruby
# frozen_string_literal: true

# =============================================================================
# scripts/manage_families â€” interactive TUI for managing project families
#
# Usage:
#   bundle exec ruby scripts/manage_families [OPTIONS]
#
# Run with --help for full usage.
# =============================================================================

require 'yaml'
require 'table_tennis'

class FamilyManager
  PROJECTS_FILE     = File.expand_path('../src/_data/projects.yml',     __dir__)
  PROJECTS_DEV_FILE = File.expand_path('../src/_data/projects_dev.yml', __dir__)
  FAMILIES_FILE     = File.expand_path('../src/_data/families.yml',     __dir__)

  # All theme values that mean "deliberately not a family member"
  NON_FAMILY_THEMES = %w[adopt-me update-me avoid-me holiday].freeze

  # Fields synced to projects_dev.yml for family members
  FAMILY_FIELDS = %w[theme family_id family_primary].freeze

  def initialize(file: PROJECTS_FILE, dev_file: PROJECTS_DEV_FILE,
                 families_file: FAMILIES_FILE,
                 auto_confirm: false, dry_run: false, color: $stdout.tty?)
    @file         = file
    @dev_file     = dev_file
    @families_file = families_file
    @auto_confirm = auto_confirm
    @dry_run      = dry_run
    @color        = color

    load!
  end

  # ============================================================================
  # Top-level entry point
  # ============================================================================

  def run
    loop do
      puts ""
      unassigned = unassigned_projects

      puts tt(
        @families.map do |fam|
          members = family_members(fam['id'])
          {
            pos:   fam['position'],
            id:    fam['id'],
            name:  fam['name'],
            count: members.size,
          }
        end +
        [{ pos: '', id: 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', name: 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€', count: '' }] +
        [{ pos: 'U', id: '(unassigned)', name: "#{unassigned.size} project(s) with no family", count: '' }] +
        [{ pos: 'N', id: '(new family)', name: 'Create a new family',                          count: '' }] +
        [{ pos: 'Q', id: '(quit)',       name: 'Save and exit',                                count: '' }],
        title:   'ğŸ  Family Manager',
        columns: %i[pos id name count],
        headers: { pos: 'Pos', id: 'Family ID', name: 'Family Name', count: '  #' },
      )

      print "\nSelect a family position # (or U / N / Q): "
      $stdout.flush
      input = $stdin.gets&.strip
      break if input.nil? || input.upcase == 'Q'

      case input.upcase
      when 'U' then manage_unassigned
      when 'N' then create_family
      else
        pos = input.to_i
        fam = @families.find { |f| f['position'] == pos }
        if fam
          manage_family(fam['id'])
        else
          puts "  âš ï¸  Invalid selection."
        end
      end
    end

    save_all
    puts "\nâœ… Done."
  end

  # ============================================================================
  # Manage a single family
  # ============================================================================

  def manage_family(fid)
    loop do
      fam     = @families.find { |f| f['id'] == fid }
      members = family_members(fid)
      puts ""
      puts tt(
        members.map.with_index(1) do |p, i|
          {
            "#":   i,
            name:  p['name'],
            role:  p['role'],
            stars: p['github_stars'],
          }
        end,
        title:        "ğŸ“¦ #{fam['name']} (#{fid})  â€”  slot #{fam['position']}",
        columns:      %i[# name role stars],
        headers:      { "#": '#', name: 'Project', role: 'Role', stars: 'â­' },
        color_scales: :stars,
      )

      puts "  Actions: [M]ove project in/out  [S]wap two members  [A]dd unassigned  [D]elete family  [P]osition (reorder among families)  [B]ack"
      print "  > "
      $stdout.flush
      action = $stdin.gets&.strip&.upcase
      break if action.nil? || action == 'B'

      case action
      when 'M' then move_member(fid)
      when 'S' then swap_members(fid)
      when 'A' then add_unassigned_to_family(fid)
      when 'D' then break if delete_family(fid)
      when 'P' then reposition_family(fid)
      end
    end
  end

  # ============================================================================
  # Reposition a family in the global order â€” edits families.yml positions only
  # ============================================================================

  def reposition_family(fid)
    fam          = @families.find { |f| f['id'] == fid }
    current_pos  = fam['position']
    max_pos      = @families.size

    puts "\n  Current family order:"
    @families.each do |f|
      marker = f['id'] == fid ? ' â—€ (selected)' : ''
      puts "    #{f['position'].to_s.rjust(2)}.  #{f['id'].ljust(32)} #{f['name']}#{marker}"
    end

    print "\n  Enter new position for '#{fam['name']}' (1â€“#{max_pos}, current = #{current_pos}): "
    $stdout.flush
    input = $stdin.gets&.strip
    return if input.nil? || input.empty?

    target = input.to_i
    return puts "  âš ï¸  Invalid position." unless target >= 1 && target <= max_pos

    if target == current_pos
      puts "  â„¹ï¸  Already at position #{current_pos}. No change."
      return
    end

    # Remove fam from list, insert at new position, then renumber 1..N
    ordered = @families.reject { |f| f['id'] == fid }
    ordered.insert(target - 1, fam)
    ordered.each_with_index { |f, i| f['position'] = i + 1 }

    puts "\n  New family order:"
    @families.each do |f|
      marker = f['id'] == fid ? ' â—€' : ''
      puts "    #{f['position'].to_s.rjust(2)}.  #{f['id'].ljust(32)} #{f['name']}#{marker}"
    end

    puts "  âœ… Position updated. Will be saved on exit."
  end

  # ============================================================================
  # Move a member out of the family (becomes unassigned)
  # ============================================================================

  def move_member(fid)
    members = family_members(fid)

    puts tt(
      members.map.with_index(1) { |p, i| { "#": i, name: p['name'] } },
      title:   'Remove member from family',
      columns: %i[# name],
      row_numbers: false,
    )

    print "  Select member # to remove (or Enter to cancel): "
    $stdout.flush
    input = $stdin.gets&.strip
    return if input.nil? || input.empty?

    idx = input.to_i - 1
    return puts "  âš ï¸  Invalid selection." unless idx >= 0 && idx < members.size

    project = members[idx]
    if confirm("Remove '#{project['name']}' from family '#{fid}'?", default: false)
      project.delete('theme')
      project.delete('family_id')
      project.delete('family_primary')
      puts "  âœ… '#{project['name']}' is now unassigned."
    end
  end

  # ============================================================================
  # Swap two members within a family (reorder within-family)
  # ============================================================================

  def swap_members(fid)
    members = family_members(fid)

    puts tt(
      members.map.with_index(1) { |p, i| { "#": i, name: p['name'] } },
      title:   'Swap member order',
      columns: %i[# name],
    )

    print "  Swap member # : "
    $stdout.flush
    a_input = $stdin.gets&.strip
    return if a_input.nil? || a_input.empty?

    print "  With member # : "
    $stdout.flush
    b_input = $stdin.gets&.strip
    return if b_input.nil? || b_input.empty?

    a_idx = a_input.to_i - 1
    b_idx = b_input.to_i - 1

    unless a_idx >= 0 && a_idx < members.size && b_idx >= 0 && b_idx < members.size && a_idx != b_idx
      puts "  âš ï¸  Invalid selection."
      return
    end

    # Swap by exchanging their positions in @projects array
    a_proj = members[a_idx]
    b_proj = members[b_idx]
    a_pos  = @projects.index(a_proj)
    b_pos  = @projects.index(b_proj)
    @projects[a_pos], @projects[b_pos] = @projects[b_pos], @projects[a_pos]
    puts "  âœ… Swapped order: #{a_proj['name']} â†” #{b_proj['name']}"
  end

  # ============================================================================
  # Add an unassigned project to this family
  # ============================================================================

  def add_unassigned_to_family(fid)
    unassigned = unassigned_projects
    if unassigned.empty?
      puts "  âœ… No unassigned projects."
      return
    end

    fam  = @families.find { |f| f['id'] == fid }
    fname = fam['name']

    puts tt(
      unassigned.map { |p| { name: p['name'], language: p['language'], ecosystem: p['ecosystem'], stars: p['github_stars'] } },
      title:        'Unassigned Projects',
      row_numbers:  true,
      color_scales: :stars,
    )

    print "  Select project # to add to '#{fname}' (or Enter to cancel): "
    $stdout.flush
    input = $stdin.gets&.strip
    return if input.nil? || input.empty?

    idx = input.to_i - 1
    return puts "  âš ï¸  Invalid selection." unless idx >= 0 && idx < unassigned.size

    project            = unassigned[idx]
    project['theme']   = 'family'
    project['family_id'] = fid

    primary = confirm("  Mark as family primary (shown first in stack)?", default: false)
    project['family_primary'] = true if primary

    puts "  âœ… Added '#{project['name']}' to '#{fname}'."
  end

  # ============================================================================
  # Manage unassigned projects
  # ============================================================================

  def manage_unassigned
    loop do
      unassigned = unassigned_projects
      if unassigned.empty?
        puts "  âœ… No unassigned projects."
        break
      end

      puts tt(
        unassigned.map { |p| { name: p['name'], language: p['language'], ecosystem: p['ecosystem'], theme: p['theme'].inspect, stars: p['github_stars'] } },
        title:        "ğŸ“‹ Unassigned Projects (#{unassigned.size})",
        row_numbers:  true,
        color_scales: :stars,
      )

      puts "  Actions: [#] Select project to assign to a family  [B]ack"
      print "  > "
      $stdout.flush
      input = $stdin.gets&.strip
      break if input.nil? || input.upcase == 'B'

      idx = input.to_i - 1
      unless idx >= 0 && idx < unassigned.size
        puts "  âš ï¸  Invalid selection."
        next
      end

      assign_project_to_family(unassigned[idx])
    end
  end

  # ============================================================================
  # Assign a single project to a family (or create a new one)
  # ============================================================================

  def assign_project_to_family(project)
    rows = @families.map do |fam|
      { pos: fam['position'], id: fam['id'], name: fam['name'], count: family_members(fam['id']).size }
    end
    rows << { pos: 'N', id: '(new)',  name: 'Create a new family', count: '' }
    rows << { pos: 'B', id: '(back)', name: 'Cancel',              count: '' }

    puts tt(rows, title: "Assign '#{project['name']}' to a family",
            columns: %i[pos id name count],
            headers: { pos: 'Pos', id: 'ID', name: 'Name', count: 'Members' })

    print "  Select family position # (or N / B): "
    $stdout.flush
    input = $stdin.gets&.strip
    return if input.nil? || input.upcase == 'B'

    fid = if input.upcase == 'N'
      meta = prompt_new_family_meta
      return unless meta
      meta[:id]
    else
      pos = input.to_i
      fam = @families.find { |f| f['position'] == pos }
      unless fam
        puts "  âš ï¸  Invalid selection."
        return
      end
      fam['id']
    end

    project['theme']     = 'family'
    project['family_id'] = fid

    primary = confirm("  Mark as family primary?", default: false)
    project['family_primary'] = true if primary

    fname = @families.find { |f| f['id'] == fid }&.dig('name') || fid
    puts "  âœ… Assigned '#{project['name']}' â†’ '#{fname}'."
  end

  # ============================================================================
  # Create a new family (adds to families.yml, optionally seeds members)
  # ============================================================================

  def create_family
    puts "\nâ”â”â” Create New Family â”â”â”"
    meta = prompt_new_family_meta
    return unless meta

    fid   = meta[:id]
    fname = meta[:name]

    # Seed initial members from unassigned
    puts "\n  Now seed initial members (optional â€” you can add more later)."
    unassigned = unassigned_projects

    if unassigned.empty?
      puts "  (No unassigned projects available.)"
    else
      loop do
        available = unassigned_projects.reject { |p| p['family_id'] == fid }
        break if available.empty?

        puts tt(
          available.map { |p| { name: p['name'], language: p['language'], ecosystem: p['ecosystem'] } },
          title:       'Available unassigned projects',
          row_numbers: true,
        )

        print "  Add project # to '#{fname}' (or Enter to finish): "
        $stdout.flush
        input = $stdin.gets&.strip
        break if input.nil? || input.empty?

        idx = input.to_i - 1
        unless idx >= 0 && idx < available.size
          puts "  âš ï¸  Invalid selection."
          next
        end

        project              = available[idx]
        project['theme']     = 'family'
        project['family_id'] = fid

        if family_members(fid).empty? && confirm("  Mark as family primary?", default: true)
          project['family_primary'] = true
        end

        puts "  âœ… Added '#{project['name']}' to '#{fname}'."
      end
    end

    puts "  Family '#{fname}' ready with #{family_members(fid).size} member(s)."
  end

  # ============================================================================
  # Delete a family (unassigns all members, removes from families.yml)
  # ============================================================================

  def delete_family(fid)
    fam     = @families.find { |f| f['id'] == fid }
    fname   = fam['name']
    members = family_members(fid)

    puts "  âš ï¸  This will UNASSIGN all #{members.size} member(s) from '#{fname}' and remove the family."
    return false unless confirm("  Delete family '#{fid}' and unassign all members?", default: false)

    members.each do |p|
      p.delete('theme')
      p.delete('family_id')
      p.delete('family_primary')
    end

    @families.delete(fam)
    # Renumber remaining families 1..N
    @families.each_with_index { |f, i| f['position'] = i + 1 }

    puts "  âœ… Family '#{fname}' deleted. #{members.size} project(s) are now unassigned."
    true
  end

  # ============================================================================
  private
  # ============================================================================

  def load!
    @projects = YAML.load_file(@file) || []
    @families = (YAML.load_file(@families_file) || []).sort_by { |f| f['position'] || 999 }
  end

  def all_family_ids
    @families.map { |f| f['id'] }
  end

  def family_members(fid)
    # Return in the order they appear in @projects (insertion order = within-family order)
    @projects.select { |p| p.is_a?(Hash) && p['family_id'] == fid }
  end

  def unassigned_projects
    @projects.select do |p|
      p.is_a?(Hash) &&
        p['type'] != 'person' &&
        p['theme'] != 'family' &&
        !NON_FAMILY_THEMES.include?(p['theme'])
    end.sort_by { |p| p['name'] }
  end

  def prompt_new_family_meta
    print "  Family ID (kebab-case, e.g. 'my-new-family'): "
    $stdout.flush
    fid = $stdin.gets&.strip
    return nil if fid.nil? || fid.empty?

    if @families.any? { |f| f['id'] == fid }
      puts "  âš ï¸  Family '#{fid}' already exists."
      return nil
    end

    print "  Family display name (e.g. 'My New Family'): "
    $stdout.flush
    fname = $stdin.gets&.strip
    return nil if fname.nil? || fname.empty?

    next_pos = (@families.map { |f| f['position'] }.max || 0) + 1
    @families << { 'id' => fid, 'name' => fname, 'position' => next_pos }
    puts "  âœ… Family '#{fname}' added at position #{next_pos}."

    { id: fid, name: fname }
  end

  def confirm(message, default: true)
    return default if @auto_confirm

    prompt = default ? '[Y/n]' : '[y/N]'
    print "#{message} #{prompt} "
    $stdout.flush
    input = $stdin.gets&.strip&.downcase
    return default if input.nil? || input.empty?
    input.start_with?('y')
  end

  def save_all
    save_projects(@file, @projects)
    save_dev_file(@dev_file) if File.exist?(@dev_file)
    save_families(@families_file, @families)
  end

  def save_projects(path, data)
    if @dry_run
      puts "  ğŸ” DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(data))
    puts "  ğŸ’¾ Saved: #{path}"
  end

  def save_dev_file(path)
    dev_data = YAML.load_file(path) || []
    name_map = @projects.each_with_object({}) { |p, h| h[p['name']] = p if p.is_a?(Hash) && p['name'] }
    dev_data.each do |dp|
      next unless dp.is_a?(Hash) && dp['name'] && name_map.key?(dp['name'])
      src = name_map[dp['name']]
      FAMILY_FIELDS.each { |f| dp[f] = src[f] }
      dp.delete('family_primary') unless src['family_primary']
      # Remove stale fields that no longer belong on project entries
      dp.delete('family_name')
      dp.delete('family_position')
    end

    if @dry_run
      puts "  ğŸ” DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(dev_data))
    puts "  ğŸ’¾ Saved: #{path}"
  end

  def save_families(path, data)
    if @dry_run
      puts "  ğŸ” DRY RUN â€” would save: #{path}"
      return
    end
    File.write(path, YAML.dump(data))
    puts "  ğŸ’¾ Saved: #{path}"
  end

  def tt(rows, **opts)
    opts[:theme] = :ansi unless @color
    TableTennis.new(rows, opts).to_s
  end
end

# =============================================================================
# CLI
# =============================================================================

if __FILE__ == $0
  file          = FamilyManager::PROJECTS_FILE
  dev_file      = FamilyManager::PROJECTS_DEV_FILE
  families_file = FamilyManager::FAMILIES_FILE
  auto_confirm  = false
  dry_run       = false
  no_color      = !$stdout.tty?

  i = 0
  while i < ARGV.size
    arg = ARGV[i]
    case arg
    when '--help', '-h'
      puts <<~HELP
        Usage: bundle exec ruby scripts/manage_families [OPTIONS]

        Interactive TUI for managing project families.

        Family metadata (name, global display order) lives in families.yml.
        Project entries in projects.yml carry only: theme, family_id, family_primary.
        Within-family member order is the order entries appear in projects.yml.

        From the main menu you can:
          â€¢ Select a family by its position number to manage its members
          â€¢ [M] Remove a member from a family (makes it unassigned)
          â€¢ [S] Swap two members' within-family order
          â€¢ [A] Add an unassigned project to the family
          â€¢ [D] Delete a family (unassigns all members, removes from families.yml)
          â€¢ [P] Reposition this family among all families (edits families.yml)
          â€¢ [U] Manage unassigned projects
          â€¢ [N] Create a new family
          â€¢ [Q] Save and exit

        Options:
          -h, --help              Show this help
          --dry-run               Preview saves without writing files
          --no-color              Disable ANSI colour output
          --file PATH             Use a different projects YAML file
          --dev-file PATH         Use a different projects_dev YAML file
          --families-file PATH    Use a different families YAML file

        Changes are written to projects.yml, projects_dev.yml, and families.yml on exit.
      HELP
      exit 0
    when '--dry-run'
      dry_run = true
    when '--no-color'
      no_color = true
    when '--file'
      file = ARGV[i += 1]
    when '--dev-file'
      dev_file = ARGV[i += 1]
    when '--families-file'
      families_file = ARGV[i += 1]
    else
      warn "Unknown option: #{arg}"
      warn 'Run with --help for usage.'
      exit 1
    end
    i += 1
  end

  FamilyManager.new(
    file:          file,
    dev_file:      dev_file,
    families_file: families_file,
    auto_confirm:  auto_confirm,
    dry_run:       dry_run,
    color:         !no_color,
  ).run
end
