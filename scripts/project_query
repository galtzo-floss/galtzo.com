#!/usr/bin/env ruby
# frozen_string_literal: true

# =============================================================================
# scripts/project_query â€” query, filter, and inspect src/_data/projects.yml
#
# Usage:
#   bundle exec ruby scripts/project_query [OPTIONS] <subcommand> [args]
#
# Run with --help for full usage.
# =============================================================================

require 'yaml'
require 'date'
require 'time'
require 'tty-prompt'
require 'pp'
require 'rbconfig'
require 'table_tennis'

class ProjectQuery
  PROJECTS_FILE  = File.expand_path('../src/_data/projects.yml', __dir__)
  CONSOLE_HELPER = File.expand_path('../tmp/project_query_console.rb', __dir__)

  # Fields expected on every non-person project
  EXPECTED_FIELDS = %w[
    name description language ecosystem minimum_version role
    first_commit_on forges tags status
    release_date last_commit_on last_scrape_at
  ].freeze

  # Ecosystems that should have download stats
  DOWNLOAD_ECOSYSTEMS = %w[rubygems cargo npm pypi].freeze

  # Ecosystems that should have a release_date
  RELEASE_DATE_ECOSYSTEMS = %w[rubygems cargo npm pypi go].freeze

  def initialize(file: PROJECTS_FILE, format: :table, color: $stdout.tty?)
    @file     = file
    @format   = format
    @color    = color
    @all      = YAML.load_file(@file) || []
    @projects = @all.reject { |p| p['type'] == 'person' }
  end

  # ============================================================================
  # Public subcommand entry points
  # ============================================================================

  def run_stats
    total   = @projects.size
    never   = @projects.count { |p| p['last_scrape_at'].nil? }
    stale7  = @projects.count { |p| days_since_scrape(p) > 7 }
    stale30 = @projects.count { |p| days_since_scrape(p) > 30 }

    stars = @projects.filter_map { |p| p['github_stars'] }.sort
    dl    = @projects.filter_map { |p| p['total_downloads'] }.sort

    meta = [
      { metric: 'Total projects',    value: total },
      { metric: 'Source file',       value: @file },
      { metric: 'Never scraped',     value: never },
      { metric: 'Scrape > 7 days',   value: stale7 },
      { metric: 'Scrape > 30 days',  value: stale30 },
    ]
    if stars.any?
      meta << { metric: 'Stars (min/avg/max/total)', value: "#{stars.first} / #{(stars.sum.to_f/stars.size).round(1)} / #{stars.last} / #{stars.sum}" }
    end
    if dl.any?
      meta << { metric: 'Downloads (min/avg/max/total)', value: "#{dl.first} / #{(dl.sum.to_f/dl.size).round(0).to_i} / #{dl.last} / #{dl.sum}" }
    end

    puts tt(meta, title: 'ğŸ“Š Project Statistics', columns: %i[metric value],
            headers: { metric: 'Metric', value: 'Value' })

    # Breakdown tables
    [
      ['Language',  'language'],
      ['Ecosystem', 'ecosystem'],
      ['Status',    'status'],
      ['Role',      'role'],
    ].each do |label, field|
      rows = @projects
        .group_by { |p| p[field].nil? ? '(nil)' : p[field] }
        .map { |val, grp| { label => val, count: grp.size } }
        .sort_by { |r| -r[:count] }
      puts tt(rows, title: label, color_scales: :count)
    end
  end

  def run_missing(field)
    abort_usage("missing requires a field name") unless field
    matches = @projects.select { |p| blank?(p[field]) }
    print_results(matches, title: "Missing '#{field}'")
  end

  def run_stale(days:)
    matches = @projects.select { |p| days_since_scrape(p) > days }
    print_results(matches, title: "Not scraped in > #{days} days")
  end

  def run_filter(field, value)
    matches = @projects.select { |p| p[field].to_s.downcase == value.downcase }
    print_results(matches, title: "#{field} = #{value}")
  end

  def run_show(name)
    project = @projects.find { |p| p['name'].to_s.downcase == name.to_s.downcase }
    if project.nil?
      matches = @projects.select { |p| p['name'].to_s.downcase.include?(name.to_s.downcase) }
      case matches.size
      when 1
        project = matches.first
      when 2..Float::INFINITY
        puts tt(matches.map { |p| { name: p['name'] } },
                title: "Ambiguous â€” #{matches.size} matches for '#{name}'")
        return
      else
        puts tt([{ message: "No project found matching '#{name}'" }], title: 'Not found')
        return
      end
    end

    case @format
    when :yaml
      puts YAML.dump([project])
    else
      # Render each field as a two-column key/value table â€” handles nested values gracefully
      rows = project.map do |k, v|
        display = case v
                  when Array then v.map { |e| e.is_a?(Hash) ? e.inspect : e.to_s }.join(', ')
                  when Hash  then v.inspect
                  else            v.to_s
                  end
        { field: k, value: display }
      end
      puts tt(rows, title: project['name'],
              columns: %i[field value],
              headers: { field: 'Field', value: 'Value' })
    end
  end

  def run_needs_attention
    issues = collect_issues + collect_family_issues
    if issues.empty?
      puts tt([{ result: 'âœ…  All projects look good â€” no issues found!' }],
              title: 'Needs Attention')
      return
    end

    rows = issues.sort_by { |i| [i[:issue], i[:name]] }
    puts tt(rows,
            title:       "âš ï¸  Needs Attention â€” #{issues.size} issue(s) across #{issues.map { |i| i[:name] }.uniq.size} project(s)",
            zebra:       true,
            row_numbers: true,
            mark:        ->(row) { %w[zero_downloads never_scraped no_forges ruby_missing_ecosystem].include?(row[:issue]) },
            columns:     %i[name issue detail])

    # Summary breakdown
    summary = issues.group_by { |i| i[:issue] }
      .map { |type, grp| { issue: type, count: grp.size } }
      .sort_by { |r| -r[:count] }
    puts tt(summary, title: 'Issue Summary', color_scales: :count, row_numbers: true)
  end

  def run_console
    require 'fileutils'
    FileUtils.mkdir_p(File.dirname(CONSOLE_HELPER))
    File.write(CONSOLE_HELPER, console_helper_source)
    puts "\e[1m\e[36mğŸ”® Launching IRB console with project data pre-loaded...\e[0m"
    puts "\e[36m   Helper: #{CONSOLE_HELPER}\e[0m\n\n"
    begin
      require 'amazing_print'
      AmazingPrint.irb!
    rescue LoadError
      # fall back to pp in IRB
    end
    require CONSOLE_HELPER
    require 'irb'
    IRB.start(__FILE__)
  end

  def run_list
    print_results(@projects, title: "All projects (#{@projects.size})")
  end

  # ============================================================================
  private
  # ============================================================================

  # â”€â”€ table_tennis wrapper â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  # Build a TableTennis table string.  Passes colour through only when @color is
  # set; otherwise forces the :ansi theme (no bg-color detection needed).
  def tt(rows, **opts)
    opts[:theme] = :ansi unless @color
    TableTennis.new(rows, opts).to_s
  end

  # â”€â”€ main project table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  def print_results(projects, title: nil)
    if projects.empty?
      puts tt([{ result: '(no matches)' }], title: title)
      return
    end

    case @format
    when :names
      projects.each { |p| puts p['name'] }

    when :yaml
      puts YAML.dump(projects)

    else # :table (default)
      rows = projects.map do |p|
        {
          name:      p['name'],
          language:  p['language'],
          ecosystem: p['ecosystem'],
          status:    p['status'],
          role:      p['role'],
          stars:     p['github_stars'],
          downloads: p['total_downloads'],
          scrape_d:  days_since_scrape(p) == Float::INFINITY ? nil : days_since_scrape(p),
        }
      end

      puts tt(rows,
              title:        title,
              zebra:        true,
              row_numbers:  true,
              color_scales: :stars,
              mark:         ->(row) { row[:status] == 'stale' || row[:status] == 'archived' },
              headers:      {
                scrape_d:  'scrape (d)',
                downloads: 'downloads',
              })
    end
  end

  # â”€â”€ Issue collectors â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  def collect_issues
    issues = []
    @projects.each do |p|
      name = p['name']
      eco  = p['ecosystem']
      lang = p['language']

      issues << row_issue(name, 'no_description',        'description is blank')         if blank?(p['description'])
      issues << row_issue(name, 'no_forges',             'forges is empty')              if blank?(p['forges'])
      issues << row_issue(name, 'no_funding_sites',      'funding_sites is nil')         if p['funding_sites'].nil?
      issues << row_issue(name, 'no_status',             'status is nil')                if p['status'].nil?
      issues << row_issue(name, 'no_tags',               'tags is empty')                if blank?(p['tags'])
      issues << row_issue(name, 'no_minimum_version',    'minimum_version is nil')       if p['minimum_version'].nil?
      issues << row_issue(name, 'no_role',               'role is nil')                  if p['role'].nil?
      issues << row_issue(name, 'no_first_commit_on',    'first_commit_on is nil')       if p['first_commit_on'].nil?

      if p['last_scrape_at'].nil?
        issues << row_issue(name, 'never_scraped',       'never been scraped')
      elsif days_since_scrape(p) > 30
        issues << row_issue(name, 'stale_scrape',        "last scraped #{days_since_scrape(p)}d ago")
      end

      if !p['last_commit_on'].nil? && days_since(p['last_commit_on']) > 365 &&
         p['status'] != 'stale' && p['status'] != 'archived'
        issues << row_issue(name, 'stale_mismatch',      "last commit #{days_since(p['last_commit_on'])}d ago but status=#{p['status']}")
      end
      issues << row_issue(name, 'no_last_commit',        'last_commit_on is nil')        if p['last_commit_on'].nil? && p['status'] != 'archived'

      if RELEASE_DATE_ECOSYSTEMS.include?(eco) && p['release_date'].nil?
        issues << row_issue(name, 'no_release_date',     "release_date nil for ecosystem=#{eco}")
      end
      if DOWNLOAD_ECOSYSTEMS.include?(eco) && (p['total_downloads'].nil? || p['total_downloads'] == 0)
        issues << row_issue(name, 'zero_downloads',      "total_downloads=#{p['total_downloads'].inspect} for ecosystem=#{eco}")
      end

      if lang == 'Ruby' && eco.nil?
        issues << row_issue(name, 'ruby_missing_ecosystem', "language=Ruby but ecosystem is nil (set to 'none' if intentional)")
      end

      unless p['role'].nil? || %w[author contributor maintainer].include?(p['role'])
        issues << row_issue(name, 'invalid_role',        "role=#{p['role']}")
      end
    end
    issues
  end

  def collect_family_issues
    family_issues = []
    @projects
      .select { |p| p['theme'] == 'family' && p['family_id'] }
      .group_by { |p| p['family_id'] }
      .each do |fid, members|
        # Duplicate positions within a family
        pos_tally = members.group_by { |p| p['family_position'] }
        pos_tally.each do |pos, dups|
          next if dups.size == 1
          dups.each do |p|
            family_issues << row_issue(p['name'], 'duplicate_family_position',
              "family=#{fid} has duplicate position #{pos}: #{dups.map { |d| d['name'] }.join(', ')}")
          end
        end
        # Missing position
        members.each do |p|
          family_issues << row_issue(p['name'], 'missing_family_position', "family=#{fid}") if p['family_position'].nil?
        end
      end
    family_issues
  end

  def row_issue(name, issue, detail = nil)
    { name: name, issue: issue, detail: detail }
  end

  # â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  def blank?(val)
    val.nil? || (val.respond_to?(:empty?) && val.empty?)
  end

  def days_since_scrape(project)
    days_since(project['last_scrape_at'])
  end

  def days_since(date_string)
    return Float::INFINITY if date_string.nil?
    parsed = Time.parse(date_string.to_s)
    ((Time.now.utc - parsed) / 86_400).round
  rescue ArgumentError, TypeError
    Float::INFINITY
  end

  def abort_usage(msg)
    warn "âŒ  #{msg}"
    warn 'Run with --help for usage.'
    exit 1
  end

  # â”€â”€ IRB console helper (written to tmp/ at runtime) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  def console_helper_source
    <<~'RUBY'
      # frozen_string_literal: true
      # Auto-generated by scripts/project_query console â€” safe to delete.
      require 'yaml'
      require 'date'
      require 'time'
      require 'pp'
      require 'table_tennis'

      _projects_file = File.expand_path('../../src/_data/projects.yml', __FILE__)
      _raw = YAML.load_file(_projects_file) || []

      # â”€â”€ Project struct â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      Project = Struct.new(
        :name, :description, :language, :ecosystem, :minimum_version,
        :role, :status, :tags, :forges,
        :github_stars, :gitlab_stars, :codeberg_stars,
        :total_downloads, :daily_downloads, :release_downloads,
        :release_date, :last_commit_on, :first_commit_on, :first_commit,
        :last_scrape_at, :docs_site, :funding_sites,
        :theme, :family_id, :family_name, :family_position,
        :raw,
        keyword_init: true
      ) do
        def self.from_h(h)
          known = members - [:raw]
          attrs = known.each_with_object({}) { |k, acc| acc[k] = h[k.to_s] }
          new(**attrs, raw: h)
        end

        def days_since_scrape
          return Float::INFINITY if last_scrape_at.nil?
          ((Time.now.utc - Time.parse(last_scrape_at.to_s)) / 86_400).round
        rescue
          Float::INFINITY
        end

        def days_since_commit
          return Float::INFINITY if last_commit_on.nil?
          (Date.today - Date.parse(last_commit_on.to_s.gsub('/', '-'))).to_i
        rescue
          Float::INFINITY
        end

        def ruby_gem?      = language == 'Ruby' && ecosystem == 'rubygems'
        def active?        = status == 'active'
        def archived?      = status == 'archived'
        def stale?         = status == 'stale'
        def never_scraped? = last_scrape_at.nil?
        def github_url     = forges&.find { |f| f['type'] == 'GitHub' }&.dig('url')

        def to_s    = "#<Project name=#{name.inspect} language=#{language.inspect} status=#{status.inspect}>"
        alias inspect to_s
      end

      # â”€â”€ Collections â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      PROJECTS_RAW = _raw.freeze
      PROJECTS     = _raw.reject { |p| p['type'] == 'person' }.freeze
      PROJS        = PROJECTS.map { |h| Project.from_h(h) }.freeze

      # â”€â”€ Table helper: print an array of Project structs as a table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      def table(projs, **opts)
        rows = Array(projs).map do |p|
          scrape = p.days_since_scrape
          {
            name:      p.name,
            language:  p.language,
            ecosystem: p.ecosystem,
            status:    p.status,
            role:      p.role,
            stars:     p.github_stars,
            downloads: p.total_downloads,
            scrape_d:  scrape == Float::INFINITY ? nil : scrape,
          }
        end
        default_opts = {
          zebra:        true,
          row_numbers:  true,
          color_scales: :stars,
          mark:         ->(row) { row[:status] == 'stale' || row[:status] == 'archived' },
          headers:      { scrape_d: 'scrape (d)' },
        }
        puts TableTennis.new(rows, default_opts.merge(opts))
      end

      # â”€â”€ Top-level helper methods â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

      def find(name)
        hit = PROJS.find { |p| p.name.to_s.downcase == name.downcase }
        hit ||= PROJS.select { |p| p.name.to_s.downcase.include?(name.downcase) }
        hit
      end

      def by_language(lang)  = PROJS.select { |p| p.language.to_s.downcase  == lang.downcase }
      def by_status(s)       = PROJS.select { |p| p.status.to_s.downcase    == s.downcase    }
      def by_role(r)         = PROJS.select { |p| p.role.to_s.downcase      == r.downcase    }
      def by_ecosystem(e)    = PROJS.select { |p| p.ecosystem.to_s.downcase == e.downcase    }
      def by_tag(t)          = PROJS.select { |p| Array(p.tags).any? { |tag| tag.downcase == t.downcase } }

      def missing(field)
        PROJS.select do |p|
          v = p.send(field) rescue nil
          v.nil? || (v.respond_to?(:empty?) && v.empty?)
        end
      end

      def stale_scrape(days: 30)  = PROJS.select { |p| p.days_since_scrape > days }
      def stale_commit(days: 365) = PROJS.select { |p| p.days_since_commit > days }
      def never_scraped           = PROJS.select(&:never_scraped?)

      def needs_attention
        issues = []
        PROJS.each do |p|
          issues << [p.name, 'no_description']   if p.description.to_s.empty?
          issues << [p.name, 'no_forges']        if Array(p.forges).empty?
          issues << [p.name, 'no_funding_sites'] if p.funding_sites.nil?
          issues << [p.name, 'no_status']        if p.status.nil?
          issues << [p.name, 'no_tags']          if Array(p.tags).empty?
          issues << [p.name, 'never_scraped']    if p.never_scraped?
          issues << [p.name, 'stale_scrape_30d'] if !p.never_scraped? && p.days_since_scrape > 30
          issues << [p.name, 'stale_mismatch']   if p.days_since_commit > 365 && p.active?
        end
        grouped = issues.group_by(&:last).transform_values { |v| v.map(&:first) }
        # Print a summary table, return the hash for further use
        summary = grouped.map { |issue, names| { issue: issue, count: names.size, projects: names.join(', ') } }
                         .sort_by { |r| -r[:count] }
        puts TableTennis.new(summary, title: 'âš ï¸  Needs Attention Summary', color_scales: :count, row_numbers: true)
        grouped
      end

      def stats
        rows = [
          { metric: 'Total',         value: PROJS.size },
          { metric: 'Never scraped', value: PROJS.count(&:never_scraped?) },
          { metric: 'Active',        value: PROJS.count(&:active?) },
          { metric: 'Stale',         value: PROJS.count(&:stale?) },
          { metric: 'Archived',      value: PROJS.count(&:archived?) },
        ]
        puts TableTennis.new(rows, title: 'Stats', columns: %i[metric value])
        nil
      end

      # â”€â”€ Welcome banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      puts TableTennis.new(
        [
          { available: 'PROJS',                description: "array of #{PROJS.size} Project structs" },
          { available: 'PROJECTS',             description: 'array of raw hashes' },
          { available: 'table(projs, **opts)', description: 'print a TableTennis table from a Project array' },
          { available: 'find(name)',           description: 'fuzzy-find a project by name' },
          { available: 'by_language(lang)',    description: 'filter by language' },
          { available: 'by_status(status)',    description: 'filter by status' },
          { available: 'by_role(role)',        description: 'filter by role' },
          { available: 'by_ecosystem(eco)',    description: 'filter by ecosystem' },
          { available: 'by_tag(tag)',          description: 'filter by tag' },
          { available: 'missing(:field)',      description: 'projects with a blank field' },
          { available: 'stale_scrape(days:)',  description: 'not scraped in N days (default 30)' },
          { available: 'stale_commit(days:)',  description: 'no commit in N days (default 365)' },
          { available: 'never_scraped',        description: 'never been scraped' },
          { available: 'needs_attention',      description: 'print issue summary, return grouped hash' },
          { available: 'stats',                description: 'print summary statistics' },
        ],
        title:   'ğŸ”® Project Query Console',
        columns: %i[available description],
        headers: { available: 'Available', description: 'Description' },
      )
    RUBY
  end
end

# =============================================================================
# CLI
# =============================================================================

if __FILE__ == $0
  require 'fileutils'
  require 'optparse'

  options = {
    format:   :table,
    days:     30,
    file:     ProjectQuery::PROJECTS_FILE,
    color:    $stdout.tty?,
  }

  OptionParser.new do |op|
    op.banner = "Usage: bundle exec ruby scripts/project_query [OPTIONS] [subcommand [args]]"

    op.separator ""
    op.separator "When run without a subcommand, an interactive menu is shown."
    op.separator ""
    op.separator "Subcommands:"
    op.separator "  list                         List all projects (table view)"
    op.separator "  stats                        Summary statistics"
    op.separator "  show <name>                  Show full entry for one project (fuzzy match)"
    op.separator "  missing <field>              Projects where the given field is blank or nil"
    op.separator "  stale [--days N]             Projects not scraped in > N days (default: 30)"
    op.separator "  status <value>               Filter by status (active|stale|archived)"
    op.separator "  language <value>             Filter by language"
    op.separator "  ecosystem <value>            Filter by ecosystem (rubygems|cargo|npm|pypi|go|none)"
    op.separator "  role <value>                 Filter by role (author|contributor|maintainer)"
    op.separator "  tag <value>                  Filter by tag"
    op.separator "  needs-attention              Full data-quality audit report"
    op.separator "  console                      Drop into IRB with project data pre-loaded"
    op.separator ""
    op.separator "Field names for `missing`:"
    op.separator "  name  description  language  ecosystem  minimum_version  role"
    op.separator "  status  tags  forges  release_date  last_commit_on  first_commit_on"
    op.separator "  github_stars  total_downloads  last_scrape_at  docs_site"
    op.separator ""
    op.separator "Examples:"
    op.separator "  bundle exec ruby scripts/project_query stats"
    op.separator "  bundle exec ruby scripts/project_query needs-attention"
    op.separator "  bundle exec ruby scripts/project_query missing ecosystem"
    op.separator "  bundle exec ruby scripts/project_query stale --days 7"
    op.separator "  bundle exec ruby scripts/project_query show version_gem"
    op.separator "  bundle exec ruby scripts/project_query tag rspec"
    op.separator "  bundle exec ruby scripts/project_query list --format names"
    op.separator "  bundle exec ruby scripts/project_query console"
    op.separator ""
    op.separator "Options:"

    op.on("--days N", Integer, "Day threshold for `stale` (default: 30)") do |n|
      options[:days] = n
    end

    op.on("--format FORMAT", %i[table names yaml], "Output format: table|names|yaml (default: table)") do |f|
      options[:format] = f
    end

    op.on("--file PATH", "Use a different projects YAML file") do |path|
      options[:file] = path
    end

    op.on("--no-color", "Disable ANSI colour / force :ansi theme") do
      options[:color] = false
    end

    op.on("-h", "--help", "Show this help") do
      puts op
      exit 0
    end
  end.parse!

  # Remaining ARGV after parse! holds the subcommand and its arguments
  subcommand = ARGV.shift
  sub_args   = ARGV.dup

  if subcommand.nil?
    prompt = TTY::Prompt.new(enable_color: options[:color])

    SUBCOMMANDS = [
      { name: 'list             â€” list all projects',                              value: 'list' },
      { name: 'stats            â€” summary statistics',                             value: 'stats' },
      { name: 'needs-attention  â€” full data-quality audit',                        value: 'needs-attention' },
      { name: 'show             â€” show full entry for one project (fuzzy match)',  value: 'show' },
      { name: 'missing          â€” projects where a field is blank or nil',         value: 'missing' },
      { name: 'stale            â€” projects not scraped recently',                  value: 'stale' },
      { name: 'status           â€” filter by status',                               value: 'status' },
      { name: 'language         â€” filter by language',                             value: 'language' },
      { name: 'ecosystem        â€” filter by ecosystem',                            value: 'ecosystem' },
      { name: 'role             â€” filter by role',                                 value: 'role' },
      { name: 'tag              â€” filter by tag',                                  value: 'tag' },
      { name: 'console          â€” drop into IRB with project data pre-loaded',     value: 'console' },
    ].freeze

    subcommand = prompt.select(
      "ğŸ“Š Project Query â€” select a subcommand:",
      SUBCOMMANDS,
      per_page: SUBCOMMANDS.size,
      cycle:    true,
      filter:   true,
    )

    # Prompt for the argument required by certain subcommands
    case subcommand
    when 'show'
      sub_args = [prompt.ask("Project name (fuzzy match):", required: true)]
    when 'missing'
      sub_args = [prompt.ask("Field name:", required: true)]
    when 'stale'
      options[:days] = prompt.ask("Not scraped in more than how many days?", default: options[:days], convert: :int)
    when 'status'
      sub_args = [prompt.select("Status:", %w[active stale archived], cycle: true)]
    when 'language'
      sub_args = [prompt.ask("Language:", required: true)]
    when 'ecosystem'
      sub_args = [prompt.select("Ecosystem:", %w[rubygems cargo npm pypi go none], cycle: true)]
    when 'role'
      sub_args = [prompt.select("Role:", %w[author contributor maintainer], cycle: true)]
    when 'tag'
      sub_args = [prompt.ask("Tag:", required: true)]
    end
  end

  pq = ProjectQuery.new(file: options[:file], format: options[:format], color: options[:color])

  case subcommand
  when 'list'
    pq.run_list
  when 'stats'
    pq.run_stats
  when 'show'
    pq.run_show(sub_args.first)
  when 'missing'
    pq.run_missing(sub_args.first)
  when 'stale'
    pq.run_stale(days: options[:days])
  when 'status'
    pq.run_filter('status', sub_args.first || '')
  when 'language'
    pq.run_filter('language', sub_args.first || '')
  when 'ecosystem'
    pq.run_filter('ecosystem', sub_args.first || '')
  when 'role'
    pq.run_filter('role', sub_args.first || '')
  when 'tag'
    tag = sub_args.first || ''
    matches = pq.instance_variable_get(:@projects)
                .select { |p| Array(p['tags']).any? { |t| t.downcase == tag.downcase } }
    pq.send(:print_results, matches, title: "tag = #{tag}")
  when 'needs-attention', 'needs_attention'
    pq.run_needs_attention
  when 'console'
    pq.run_console
  else
    warn "Unknown subcommand: #{subcommand.inspect}"
    warn 'Run with --help for usage.'
    exit 1
  end
end
