#!/usr/bin/env ruby
# frozen_string_literal: true

# =============================================================================
# scripts/analyze_tags â€” analyse, rationalise, and merge tags in projects.yml
#
# Usage:
#   bundle exec ruby scripts/analyze_tags [OPTIONS]
#
# Run with --help for full usage.
# =============================================================================

require 'yaml'
require 'table_tennis'
require 'set'

class TagAnalyzer
  PROJECTS_FILE     = File.expand_path('../src/_data/projects.yml',     __dir__)
  PROJECTS_DEV_FILE = File.expand_path('../src/_data/projects_dev.yml', __dir__)

  # ---------------------------------------------------------------------------
  # Suggested canonical renames: { "old_tag" => "canonical_tag" }
  #
  # Philosophy: prefer the shortest, most widely-used form; collapse synonyms
  # and near-duplicates; raise singletons into a broader existing tag where
  # semantically justified.
  # ---------------------------------------------------------------------------
  SUGGESTED_RENAMES = {
    # test / rspec / testing â†’ test
    'testing'          => 'test',
    'rspec'            => 'test',
    'mock'             => 'test',
    'harness'          => 'test',
    'coverage'         => 'test',
    'fuzz'             => 'test',

    # log / debug â†’ log
    'debug'            => 'log',

    # error-handle â†’ errors
    'error-handle'     => 'errors',

    # auth / security â†’ security
    'auth'             => 'security',

    # cli / tty / terminal â†’ cli
    'tty'              => 'cli',
    'terminal'         => 'cli',

    # tui / tty / terminal (tui is distinct but tiny) â†’ cli
    'tui'              => 'cli',

    # perf / benchmark â†’ perf
    'benchmark'        => 'perf',

    # regex (only 2 uses, already well-described by context) â†’ parsing
    'regex'            => 'parsing',

    # serialize â†’ serialization
    'serialize'        => 'serialization',

    # validate â†’ validation
    'validate'         => 'validation',

    # presenter â†’ view
    'presenter'        => 'view',

    # toast â†’ flash  (toast is the UI term; flash is the Rails term already in use)
    'toast'            => 'flash',

    # GHA â†’ ci  (GitHub Actions is CI)
    'GHA'              => 'ci',

    # rake â†’ bundler  (rake is a build tool, closest existing tag)
    'rake'             => 'bundler',

    # gemfile â†’ bundler
    'gemfile'          => 'bundler',

    # git â†’ vcs
    'git'              => 'vcs',

    # release / semver â†’ release
    'semver'           => 'release',

    # funding / awesome-list â†’ meta  (site-meta/community tags)
    'funding'          => 'meta',
    'awesome-list'     => 'meta',

    # wip / experimental â†’ experimental
    'wip'              => 'experimental',

    # state-machine â†’ state-machine  (keep, it's distinct)

    # service-objects â†’ service-objects  (keep, it's distinct)

    # async â†’ concurrency
    'async'            => 'concurrency',

    # migration â†’ rails  (always an ActiveRecord/Rails migration tool)
    'migration'        => 'rails',

    # dynamodb â†’ aws
    'dynamodb'         => 'aws',

    # payment â†’ api  (remit is a payment API integration)
    'payment'          => 'api',

    # package-manager â†’ bundler  (ore-light is a Ruby gem packager)
    'package-manager'  => 'bundler',

    # csv â†’ data
    'csv'              => 'data',

    # hash â†’ data
    'hash'             => 'data',

    # math â†’ data
    'math'             => 'data',

    # time â†’ data
    'time'             => 'data',

    # search â†’ api  (awesome_search is a search API layer)
    'search'           => 'api',

    # websocket â†’ api
    'websocket'        => 'api',
  }.freeze

  def initialize(file: PROJECTS_FILE, dev_file: PROJECTS_DEV_FILE,
                 auto_confirm: false, interactive: false,
                 renames_file: nil, dry_run: false, color: $stdout.tty?)
    @file         = file
    @dev_file     = dev_file
    @auto_confirm = auto_confirm
    @interactive  = interactive
    @renames_file = renames_file
    @dry_run      = dry_run
    @color        = color

    @raw      = YAML.load_file(@file) || []
    @projects = @raw.reject { |p| p['type'] == 'person' }
  end

  # ============================================================================
  # Public entry points
  # ============================================================================

  # Full analysis report â€” always runs first regardless of mode.
  def run_analyze
    freq    = tag_freq(@projects)
    all     = @projects.flat_map { |p| Array(p['tags']) }
    unique  = freq.size
    total   = all.size
    singles = freq.count { |_, c| c == 1 }
    doubles = freq.count { |_, c| c == 2 }

    # â”€â”€ Overview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Note: values must include at least one non-numeric entry (or a unit suffix)
    # so table_tennis treats the column as text rather than promoting it to float.
    overview = [
      { metric: 'Total unique tags',          value: "#{unique} tags" },
      { metric: 'Total tag usages',           value: "#{total} usages" },
      { metric: 'Avg usages per tag',         value: (total.to_f / unique).round(1).to_s },
      { metric: 'Singleton tags (used once)', value: "#{singles} tags" },
      { metric: 'Doubleton tags (used twice)',value: "#{doubles} tags" },
      { metric: 'Tags used â‰¥ 3 times',        value: "#{freq.count { |_, c| c >= 3 }} tags" },
      { metric: 'Tags used â‰¥ 5 times',        value: "#{freq.count { |_, c| c >= 5 }} tags" },
    ]
    puts tt(overview, title: 'ğŸ“ Tag Spread Analysis â€” Overview',
            columns: %i[metric value], headers: { metric: 'Metric', value: 'Value' })

    # â”€â”€ Full frequency table â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    rows = freq.sort_by { |_, c| -c }.map do |tag, count|
      tier = case count
             when 1     then 'singleton'
             when 2     then 'doubleton'
             when 3..4  then 'rare'
             when 5..9  then 'moderate'
             when 10..  then 'common'
             end
      { tag: tag, count: count, tier: tier }
    end
    puts tt(rows, title: 'All Tags by Frequency',
            zebra: true, row_numbers: true, color_scales: :count,
            mark: ->(r) { r[:tier] == 'singleton' || r[:tier] == 'doubleton' })

    # â”€â”€ Suggested merges â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # Only show merges where the "old" tag actually exists in the data
    active_renames = SUGGESTED_RENAMES.select { |old, _| freq.key?(old) }

    if active_renames.any?
      # Group by canonical target to show what collapses into what
      by_target = active_renames.group_by { |_, can| can }
      merge_rows = by_target.flat_map do |canonical, pairs|
        pairs.map do |old_tag, _|
          {
            old_tag:   old_tag,
            canonical: canonical,
            usages:    freq[old_tag] || 0,
            target_usages: freq[canonical] || 0,
          }
        end
      end.sort_by { |r| [r[:canonical], -r[:usages]] }

      puts tt(merge_rows,
              title:   'ğŸ’¡ Suggested Tag Merges (old â†’ canonical)',
              zebra:   true,
              row_numbers: true,
              headers: { old_tag: 'Old tag', canonical: 'Canonical', usages: 'Uses (old)', target_usages: 'Uses (target)' })

      after_unique = simulate_after_unique(freq, active_renames)
      after_total  = total  # tag count doesn't change, just unique count

      puts tt([
        { metric: 'Unique tags before merge', value: "#{unique} tags" },
        { metric: 'Unique tags after merge',  value: "#{after_unique} tags" },
        { metric: 'Reduction',                value: "âˆ’#{unique - after_unique} tags (#{((unique - after_unique) * 100.0 / unique).round(1)}%)" },
      ], title: 'ğŸ“‰ Impact Estimate', columns: %i[metric value],
         headers: { metric: 'Metric', value: 'Value' })
    else
      puts "\nâœ…  No suggested merges are applicable to the current tag set.\n"
    end

    active_renames
  end

  # Apply a renames hash (old â†’ canonical) to both projects files.
  def run_apply(renames)
    return if renames.empty?

    puts "\n" + "=" * 60
    if @dry_run
      puts "ğŸ”  DRY RUN â€” no files will be written"
    else
      puts "âœï¸   Applying #{renames.size} rename(s) to projects.yml â€¦"
    end
    puts "=" * 60

    [@file, @dev_file].each do |path|
      next unless File.exist?(path)
      data     = YAML.load_file(path) || []
      changed  = 0

      data.each do |entry|
        next unless entry.is_a?(Hash)
        tags = Array(entry['tags'])
        new_tags = tags.map { |t| renames[t] || t }.uniq.sort
        if new_tags != tags.sort
          changed += 1
          entry['tags'] = new_tags unless @dry_run
        end
      end

      if @dry_run
        puts "  #{File.basename(path)}: #{changed} project(s) would be updated"
      else
        save_yaml(path, data)
        puts "  #{File.basename(path)}: #{changed} project(s) updated"
      end
    end

    puts "\nâœ…  Done." unless @dry_run
  end

  # Interactive mode: walk through each suggested merge and confirm individually.
  def run_interactive(suggested_renames)
    return if suggested_renames.empty?
    freq = tag_freq(@projects)

    approved = {}
    puts "\n" + "=" * 60
    puts "ğŸ¾  INTERACTIVE TAG MERGE"
    puts "    Press Enter to accept [Y/n], or type a different canonical name."
    puts "=" * 60 + "\n"

    by_target = suggested_renames.group_by { |_, can| can }
    by_target.sort_by { |can, _| can }.each do |canonical, pairs|
      pairs.sort_by { |old, _| -(freq[old] || 0) }.each do |old_tag, _|
        old_count    = freq[old_tag] || 0
        target_count = freq[canonical] || 0
        print "\n  Rename #{old_tag.inspect} (#{old_count} uses) â†’ #{canonical.inspect} (#{target_count} uses)  [Y/n/custom]: "
        $stdout.flush

        if @auto_confirm
          puts "y [auto]"
          approved[old_tag] = canonical
          next
        end

        input = $stdin.gets&.strip
        case input&.downcase
        when '', 'y', 'yes'
          approved[old_tag] = canonical
        when 'n', 'no'
          puts "    â­ï¸  Skipped."
        else
          # Treat non-empty non-y/n input as a custom canonical name
          approved[old_tag] = input
          puts "    â†’ Will rename to #{input.inspect}"
        end
      end
    end

    if approved.empty?
      puts "\nNo renames approved â€” nothing to write."
      return
    end

    puts "\n"
    rows = approved.map { |old, can| { old_tag: old, canonical: can } }
    puts tt(rows, title: "âœ…  Approved Renames (#{approved.size})",
            headers: { old_tag: 'Old tag', canonical: 'Canonical' })

    run_apply(approved)
  end

  # Load a renames YAML file (format: { old: canonical, ... }) and apply.
  def run_from_file(path)
    unless File.exist?(path)
      warn "âŒ  Renames file not found: #{path}"
      exit 1
    end
    renames = YAML.load_file(path)
    unless renames.is_a?(Hash)
      warn "âŒ  Renames file must be a YAML hash mapping old_tag: canonical_tag"
      exit 1
    end
    run_apply(renames)
  end

  # ============================================================================
  private
  # ============================================================================

  def tag_freq(projects)
    projects.flat_map { |p| Array(p['tags']) }.tally
  end

  def simulate_after_unique(freq, renames)
    # Merge old tags into canonicals and count unique surviving keys
    merged = {}
    freq.each do |tag, count|
      canonical = renames[tag] || tag
      merged[canonical] = (merged[canonical] || 0) + count
    end
    merged.size
  end

  def tt(rows, **opts)
    opts[:theme] = :ansi unless @color
    TableTennis.new(rows, opts).to_s
  end

  def confirm(message, default: true)
    return default if @auto_confirm
    prompt = default ? '[Y/n]' : '[y/N]'
    print "#{message} #{prompt} "
    $stdout.flush
    input = $stdin.gets&.strip&.downcase
    return default if input.nil? || input.empty?
    input.start_with?('y')
  end

  def save_yaml(file_path, data)
    # Preserve any header comments above the YAML data
    existing = File.exist?(file_path) ? File.read(file_path) : ''
    header_lines = []
    existing.each_line do |line|
      break unless line.strip.start_with?('#') || line.strip == '---' || line.strip.empty?
      header_lines << line if line.strip.start_with?('#')
    end
    header = header_lines.join

    yaml_content = YAML.dump(data)
    final = if header.empty?
      yaml_content
    else
      lines = yaml_content.lines
      lines.first&.strip == '---' ? lines.first + header + "\n" + lines[1..].join : "---\n#{header}\n#{yaml_content}"
    end

    File.write(file_path, final)
    puts "  ğŸ’¾ Saved: #{file_path}"
  end
end

# =============================================================================
# CLI
# =============================================================================

if __FILE__ == $0
  require 'optparse'

  options = {
    file:         TagAnalyzer::PROJECTS_FILE,
    dev_file:     TagAnalyzer::PROJECTS_DEV_FILE,
    auto_confirm: false,
    interactive:  false,
    renames_file: nil,
    dry_run:      false,
    color:        $stdout.tty?,
  }

  OptionParser.new do |op|
    op.banner = "Usage: bundle exec ruby scripts/analyze_tags [OPTIONS]"

    op.separator ""
    op.separator "Analyses tag usage across projects.yml, reports the spread and frequency,"
    op.separator "and optionally merges/renames tags to reduce the total unique count."
    op.separator ""
    op.separator "Modes (default: analysis report only):"
    op.separator "  --interactive, -i       Walk through each suggested rename interactively"
    op.separator "  --apply RENAMES_FILE    Apply renames from a YAML file (format: old: canonical)"
    op.separator "  --dry-run               Show what would change without writing any files"
    op.separator ""
    op.separator "The renames file format (for --apply) is a simple YAML hash:"
    op.separator "  testing: test"
    op.separator "  rspec: test"
    op.separator "  auth: security"
    op.separator ""
    op.separator "Examples:"
    op.separator "  bundle exec ruby scripts/analyze_tags"
    op.separator "  bundle exec ruby scripts/analyze_tags --interactive"
    op.separator "  bundle exec ruby scripts/analyze_tags --interactive -y"
    op.separator "  bundle exec ruby scripts/analyze_tags --interactive -y --dry-run"
    op.separator "  bundle exec ruby scripts/analyze_tags --apply tmp/my_renames.yml"
    op.separator ""
    op.separator "Options:"

    op.on("-i", "--interactive", "Walk through each suggested rename interactively") do
      options[:interactive] = true
    end

    op.on("-y", "--no-tty", "Auto-accept all prompts (for use with --interactive)") do
      options[:auto_confirm] = true
    end

    op.on("--dry-run", "Show what would change without writing any files") do
      options[:dry_run] = true
    end

    op.on("--no-color", "Disable ANSI colour output") do
      options[:color] = false
    end

    op.on("--apply RENAMES_FILE", "Apply renames from a YAML file") do |path|
      options[:renames_file] = path
    end

    op.on("--file PATH", "Use a different projects YAML file") do |path|
      options[:file] = path
    end

    op.on("--dev-file PATH", "Use a different projects_dev YAML file") do |path|
      options[:dev_file] = path
    end

    op.on("-h", "--help", "Show this help") do
      puts op
      exit 0
    end
  end.parse!

  analyzer = TagAnalyzer.new(**options)

  # Always run the analysis report first
  suggested = analyzer.run_analyze

  if options[:renames_file]
    analyzer.run_from_file(options[:renames_file])
  elsif options[:interactive]
    analyzer.run_interactive(suggested)
  end
end
