#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'net/http'
require 'json'
require 'uri'
require 'date'
require 'time'
require 'tty-prompt'

class ProjectUpdater
  PROJECTS_FILE = File.expand_path('../src/_data/projects.yml', __dir__)
  PROJECTS_DEV_FILE = File.expand_path('../src/_data/projects_dev.yml', __dir__)

  # API tokens from environment (optional but recommended to avoid rate limits)
  GITHUB_TOKEN = ENV['GITHUB_TOKEN']
  GITLAB_TOKEN = ENV['GITLAB_TOKEN']
  RUBYGEMS_HANDLE = ENV['RUBYGEMS_HANDLE']

  # Skip projects scraped within the last 24 hours
  SCRAPE_THRESHOLD_HOURS = 24

  # Valid fields for surgical updates
  VALID_SURGICAL_FIELDS = %w[
    github_stars gitlab_stars codeberg_stars
    total_downloads daily_downloads release_downloads
    release_date last_commit_on status
  ]

  def initialize(surgical_field: nil, discover_rubygems: true, auto_confirm: false)
    # SAFETY CHECK: projects_dev.yml must exist
    # If it doesn't exist, it means scripts/devswap was run but not run again to restore prod
    # This risks deploying dev/test projects to production
    unless File.exist?(PROJECTS_DEV_FILE)
      abort <<~ERROR
        
        âŒ FATAL ERROR: projects_dev.yml does not exist!
        
        This indicates that scripts/devswap has been run to swap dev and prod projects,
        but has not been run again to restore the production projects.yml file.
        
        Running this script now would risk deploying dev/test projects to production.
        
        To fix this issue:
          1. Run: scripts/devswap
             (This will swap the files back to the correct state)
          2. Then run this script again
        
        Aborting to prevent accidental deployment of dev/test data.
      ERROR
    end

    @projects = load_yaml(PROJECTS_FILE)
    @projects_dev = load_yaml(PROJECTS_DEV_FILE)
    @rate_limit_delay = 1 # seconds between API calls
    @errors = [] # Track errors for summary
    @surgical_field = surgical_field
    @discover_rubygems = discover_rubygems
    @auto_confirm = auto_confirm
    @prompt = TTY::Prompt.new

    # Preserve header comments from YAML files
    @projects_header = extract_yaml_header(PROJECTS_FILE)
    @projects_dev_header = extract_yaml_header(PROJECTS_DEV_FILE)

    if @surgical_field && !VALID_SURGICAL_FIELDS.include?(@surgical_field)
      raise "Invalid surgical field: #{@surgical_field}. Valid fields: #{VALID_SURGICAL_FIELDS.join(', ')}"
    end
  end

  def run
    puts "="*80
    puts "ğŸ” PRE-FLIGHT: RUBYGEMS DISCOVERY"
    puts "="*80

    # Always run discovery analysis first (unless explicitly disabled)
    if @discover_rubygems
      if RUBYGEMS_HANDLE
        missing_gems = discover_missing_gems
        if missing_gems.any?
          puts "\nğŸ“¦ #{missing_gems.size} gem(s) on RubyGems.org are not yet in projects.yml:"
          missing_gems.each { |name| puts "  â€¢ #{name}" }
          puts ""
          if confirm("â• Add these #{missing_gems.size} missing gem(s) to projects.yml now?", default: true)
            add_missing_gems(missing_gems)
          else
            puts "  â­ï¸  Skipping gem discovery."
          end
        else
          puts "âœ… All RubyGems for #{RUBYGEMS_HANDLE} are already in projects.yml."
        end
      else
        puts "âš ï¸  RUBYGEMS_HANDLE is not set â€” skipping discovery."
        puts "   Set it in your environment to enable automatic gem discovery."
        puts "   Use --no-discover to suppress this warning."
      end
    else
      puts "â­ï¸  RubyGems discovery skipped (--no-discover)."
    end

    puts ""
    puts "="*80
    puts "Starting project update..."

    if @surgical_field
      puts "ğŸ”¬ SURGICAL UPDATE MODE: Only updating '#{@surgical_field}' field"
      puts "   (Ignoring last_scrape_at timestamps)"
    end
    puts "Processing #{@projects.size} projects from #{PROJECTS_FILE}"
    puts "GitHub Token: #{GITHUB_TOKEN ? 'âœ… Set' : 'âŒ Not set'}"
    puts "GitLab Token: #{GITLAB_TOKEN ? 'âœ… Set' : 'âŒ Not set'}"
    puts "RubyGems Handle: #{RUBYGEMS_HANDLE ? "âœ… Set (#{RUBYGEMS_HANDLE})" : 'âŒ Not set'}"

    non_person = @projects.count { |p| p['type'] != 'person' }
    skippable  = @projects.count { |p| p['type'] != 'person' && !@surgical_field && recently_scraped?(p) }
    to_update  = non_person - skippable
    puts ""
    puts "  #{non_person} projects total, #{skippable} recently scraped (will skip), #{to_update} to update."
    puts ""

    unless confirm("â–¶ï¸  Proceed with updating #{to_update} project(s)?", default: true)
      puts "Aborted."
      exit 0
    end

    puts ""
    skipped_count = 0
    updated_count = 0

    @projects.each_with_index do |project, index|
      # Skip the person entry
      if project['type'] == 'person'
        puts "[#{index + 1}/#{@projects.size}] Skipping person entry: #{project['name']}"
        next
      end

      # Check if project was recently scraped (skip this check in surgical mode)
      if !@surgical_field && recently_scraped?(project)
        puts "[#{index + 1}/#{@projects.size}] â­ï¸  Skipping (scraped #{time_ago(project['last_scrape_at'])}): #{project['name']}"
        skipped_count += 1
        next
      end

      puts "\n[#{index + 1}/#{@projects.size}] Processing: #{project['name']}"

      begin
        if @surgical_field
          update_single_field(project, @surgical_field)
        else
          update_project(project)
          # Set the scrape timestamp only for full updates
          project['last_scrape_at'] = Time.now.utc.iso8601
        end

        # If this project exists in projects_dev, sync it
        sync_to_dev(project)

        updated_count += 1
        sleep(@rate_limit_delay) # Rate limiting
      rescue => e
        error_msg = "#{project['name']}: #{e.message}"
        @errors << error_msg
        puts "  âŒ ERROR: #{e.message}"
        puts "  #{e.backtrace.first}"
      end
    end

    save_yaml(PROJECTS_FILE, @projects)
    save_yaml(PROJECTS_DEV_FILE, @projects_dev)

    puts "\n" + "="*80
    puts "ğŸ“Š Summary"
    puts "="*80
    puts "Updated: #{updated_count}"
    puts "Skipped (recent): #{skipped_count}"
    puts "Errors: #{@errors.size}"

    if @errors.any?
      puts "\nâš ï¸  Problems Encountered:"
      @errors.each do |error|
        puts "  â€¢ #{error}"
      end
    end

    puts "\nâœ… Update complete!"
  end

  # run_add_project is declared further down but must be public â€” Ruby resolves
  # visibility at method-definition time, so we re-open public scope here.
  public

  private

  # Prompt the user for a yes/no answer.
  # In auto-confirm mode (@auto_confirm) the default is accepted immediately.
  # Returns true for yes, false for no.
  def confirm(message, default: true)
    if @auto_confirm
      answer = default ? 'y' : 'n'
      puts "#{message} [auto: #{answer}]"
      return default
    end

    prompt = default ? "[Y/n]" : "[y/N]"
    print "#{message} #{prompt} "
    $stdout.flush
    input = $stdin.gets&.strip&.downcase
    # Empty input â†’ accept the default
    return default if input.nil? || input.empty?
    input.start_with?('y')
  end

  # Returns the list of gem names on RubyGems.org that are absent from projects.yml.
  def discover_missing_gems
    puts "  Querying RubyGems.org for gems owned by #{RUBYGEMS_HANDLE}..."
    rubygems = fetch_user_rubygems(RUBYGEMS_HANDLE)

    if rubygems.empty?
      puts "  âš ï¸  No gems found for #{RUBYGEMS_HANDLE} â€” check the handle and your network."
      return []
    end

    puts "  Found #{rubygems.size} gem(s) owned by #{RUBYGEMS_HANDLE} on RubyGems.org."

    existing_gems = @projects
      .select { |p| p['language'] == 'Ruby' && p['ecosystem'] == 'rubygems' }
      .map { |p| p['name'] }

    rubygems.reject { |gem_name| existing_gems.include?(gem_name) }
  end

  # Adds each gem in +missing_gems+ to projects.yml (and projects_dev.yml),
  # then saves both files.
  def add_missing_gems(missing_gems)
    puts "\nğŸ”¨ Adding #{missing_gems.size} missing gem(s) to projects.yml..."
    errors_before = @errors.size

    missing_gems.each_with_index do |gem_name, index|
      puts "\n[#{index + 1}/#{missing_gems.size}] Adding: #{gem_name}"

      begin
        new_project = build_project_from_rubygem(gem_name)
        @projects << new_project
        puts "  âœ… Added #{gem_name}"

        @projects_dev << new_project.dup
        puts "  ğŸ’¾ Saved to projects.yml"
        puts "  ğŸ”„ Synced to projects_dev.yml"

        sleep(@rate_limit_delay)
      rescue => e
        error_msg = "Failed to add #{gem_name}: #{e.message}"
        @errors << error_msg
        puts "  âŒ ERROR: #{e.message}"
      end
    end

    added = missing_gems.size - (@errors.size - errors_before)
    save_yaml(PROJECTS_FILE, @projects)
    save_yaml(PROJECTS_DEV_FILE, @projects_dev) if @projects_dev
    puts "\nâœ… Discovery complete! Added #{added} of #{missing_gems.size} gem(s)."
  end


  # ============================================================================
  # ADD PROJECT SUBCOMMAND
  # ============================================================================

  # Supported ecosystems and their display labels.
  ECOSYSTEMS = {
    'rubygems' => { label: 'RubyGems',   language: 'Ruby'       },
    'cargo'    => { label: 'Cargo',      language: 'Rust'       },
    'npm'      => { label: 'npm',        language: 'JavaScript' },
    'pypi'     => { label: 'PyPI',       language: 'Python'     },
    'go'       => { label: 'Go Modules', language: 'Go'         },
    'none'     => { label: 'None',       language: nil          },
  }.freeze

  # Interactive (or flag-driven) wizard to add a single project to projects.yml.
  # +opts+ is a Hash of pre-supplied values from the command line (may be empty).
  public
  def run_add_project(opts = {})
    puts "="*80
    puts "â• ADD PROJECT"
    puts "="*80
    puts "Answer the prompts below. Press Enter to accept [defaults]."
    puts "Values pre-supplied via flags are shown and confirmed automatically."
    puts ""

    project = {}

    # â”€â”€ Name â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    project['name'] = ask("Project name", default: opts[:name])

    # â”€â”€ Ecosystem â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    eco_list = ECOSYSTEMS.keys.join(', ')
    raw_eco  = ask("Package ecosystem (#{eco_list})", default: opts[:ecosystem] || 'none')
    ecosystem = ECOSYSTEMS.key?(raw_eco) ? raw_eco : 'none'
    project['ecosystem'] = ecosystem

    inferred_language = ECOSYSTEMS[ecosystem][:language]

    # â”€â”€ Language â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    project['language'] = ask("Primary language", default: opts[:language] || inferred_language || 'Ruby')

    # â”€â”€ Role â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    role = ask("Your role (author/contributor/maintainer)", default: opts[:role] || 'contributor')
    project['role'] = role

    # â”€â”€ Forge URLs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    puts ""
    puts "  Forges (press Enter to skip any):"
    forges = []

    github_url = ask("  GitHub URL", default: opts[:github_url])
    if github_url && !github_url.empty?
      github_url = github_url.sub(/\.git$/, '').sub(%r{/tree/.*}, '').sub(%r{/blob/.*}, '')
      owner = github_url.match(%r{github\.com/([^/]+)/})&.send(:[], 1)
      forges << { 'type' => 'GitHub', 'url' => github_url, 'owner' => owner }
    end

    gitlab_url = ask("  GitLab URL", default: opts[:gitlab_url])
    if gitlab_url && !gitlab_url.empty?
      owner = gitlab_url.match(%r{gitlab\.com/([^/]+)/})&.send(:[], 1)
      forges << { 'type' => 'GitLab', 'url' => gitlab_url, 'owner' => owner }
    end

    codeberg_url = ask("  Codeberg URL", default: opts[:codeberg_url])
    if codeberg_url && !codeberg_url.empty?
      owner = codeberg_url.match(%r{codeberg\.org/([^/]+)/})&.send(:[], 1)
      forges << { 'type' => 'Codeberg', 'url' => codeberg_url, 'owner' => owner }
    end

    project['forges'] = forges

    # â”€â”€ Description â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    puts ""
    project['description'] = ask("Description (can be HTML)", default: opts[:description])

    # â”€â”€ Minimum runtime version â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    version_label = case project['language']
    when 'Ruby'       then 'Minimum Ruby version (e.g. 2.7)'
    when 'Rust'       then 'Minimum Rust edition (e.g. 2021)'
    when 'Python'     then 'Minimum Python version (e.g. 3.9)'
    when 'JavaScript',
         'TypeScript' then 'Minimum Node version (e.g. 18)'
    when 'Go'         then 'Minimum Go version (e.g. 1.21)'
    else                   'Minimum runtime version'
    end
    project['minimum_version'] = ask(version_label, default: opts[:minimum_version])

    # â”€â”€ Tags â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    raw_tags = ask("Tags (comma-separated)", default: opts[:tags])
    project['tags'] = raw_tags ? raw_tags.split(',').map(&:strip).reject(&:empty?) : []

    # â”€â”€ Funding sites â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # funding_sites is a required field (index.html raises if nil).
    # Start with a sensible default based on role, then let the user amend.
    puts ""
    puts "  Funding sites:"
    default_funding = if project['role'] == 'author'
      [
        { 'type' => 'OpenCollective', 'url' => 'https://opencollective.com/galtzo-floss' },
        { 'type' => 'Liberapay',      'url' => 'https://liberapay.com/pboling' },
      ]
    else
      []
    end

    funding_sites = if opts[:funding_sites]
      # Pre-supplied via --funding-sites flag (TYPE:URL,TYPE:URL format)
      raw_fs = opts[:funding_sites].to_s.strip
      if raw_fs.downcase == 'none' || raw_fs.empty?
        puts "  Funding sites: (empty list) [pre-supplied]"
        []
      else
        parsed = raw_fs.split(',').filter_map do |entry|
          type, url = entry.strip.split(':', 2)
          { 'type' => type.strip, 'url' => url.strip } if type && url
        end
        puts "  Funding sites: #{parsed.map { |f| "#{f['type']}: #{f['url']}" }.join(', ')} [pre-supplied]"
        parsed
      end
    else
      # Collect all known funding types from existing projects (icon names must match)
      known_types = @projects
        .flat_map { |p| Array(p['funding_sites']).map { |f| f['type'] } }
        .compact.uniq.sort

      puts "  Default: #{default_funding.empty? ? '(empty list â€” no funding sites)' : default_funding.map { |f| "#{f['type']}: #{f['url']}" }.join(', ')}"
      result = default_funding.dup

      loop do
        puts ""
        puts "  Current: #{result.empty? ? '(none)' : result.map { |f| "#{f['type']}: #{f['url']}" }.join(', ')}"

        # Build type choices: known types + "new" sentinel + done/none actions
        type_choices = known_types.map { |t| { name: t, value: t } }
        type_choices << { name: 'â”€' * 40, value: :separator, disabled: '' }
        type_choices << { name: 'âœï¸  Enter a new type manually', value: :new_type }
        type_choices << { name: 'ğŸš«  Set to empty list (none)',   value: :none }
        type_choices << { name: 'âœ…  Done adding',                value: :done }

        selected = @prompt.select(
          "Add a funding site â€” select type:",
          type_choices,
          per_page: type_choices.size,
          cycle:    true,
          filter:   true,
        )

        case selected
        when :done
          break
        when :none
          result = []
          @prompt.ok "Funding sites cleared to empty list."
          break
        when :new_type
          new_type = @prompt.ask("New funding type name (must match icon filename, e.g. 'GitHub Sponsors'):") do |q|
            q.required true
            q.modify   :strip
          end
          next unless new_type
          # Add to known_types so it appears in subsequent iterations
          known_types << new_type unless known_types.include?(new_type)
          selected_type = new_type
        else
          selected_type = selected
        end

        url = @prompt.ask("URL for '#{selected_type}':") do |q|
          q.required true
          q.modify   :strip
        end
        next unless url

        result << { 'type' => selected_type, 'url' => url }
        @prompt.ok "Added: #{selected_type}: #{url}"
      end
      result
    end
    project['funding_sites'] = funding_sites
    puts ""
    puts "="*80
    puts "ğŸŒ Fetching data from APIs..."
    puts "="*80

    # Ecosystem-specific download stats
    case ecosystem
    when 'rubygems'
      pkg = project['name']
      puts "  Querying RubyGems for: #{pkg}"
      gem_info = fetch_rubygems_info(pkg)
      gem_data = api_request("https://rubygems.org/api/v1/gems/#{pkg}.json")
      if gem_data
        project['description'] ||= gem_data['info'] || gem_data['summary']
        project['docs_site']     = gem_data['documentation_uri']
        req_ver = gem_data['required_ruby_version'] || '>= 0'
        project['minimum_version'] ||= extract_minimum_version(req_ver)
        project['tags'] = (project['tags'] + determine_tags_from_gem(gem_data)).uniq.sort if project['tags'].empty?
      end
      if gem_info
        project['total_downloads']   = gem_info[:total_downloads]
        project['daily_downloads']   = gem_info[:daily_downloads]
        project['release_downloads'] = gem_info[:release_downloads]
        puts "    ğŸ“¦ Downloads: #{gem_info[:total_downloads]} total"
      end
      project['release_date'] = fetch_rubygems_release_date(pkg)
      puts "    ğŸ“… Latest release: #{project['release_date'] || 'unknown'}"

    when 'cargo'
      pkg = project['name']
      puts "  Querying crates.io for: #{pkg}"
      cargo_info = fetch_cargo_info(pkg)
      if cargo_info
        project['description']     ||= cargo_info[:description]
        project['total_downloads']   = cargo_info[:total_downloads]
        project['release_downloads'] = cargo_info[:release_downloads]
        project['release_date']      = cargo_info[:release_date]
        project['minimum_version'] ||= cargo_info[:rust_version]
        if forges.none? { |f| f['type'] == 'GitHub' } && cargo_info[:repository]
          url = cargo_info[:repository].sub(/\.git$/, '')
          if url.include?('github.com')
            owner = url.match(%r{github\.com/([^/]+)/})&.send(:[], 1)
            forges << { 'type' => 'GitHub', 'url' => url, 'owner' => owner }
            project['forges'] = forges
          end
        end
        puts "    ğŸ“¦ Downloads: #{cargo_info[:total_downloads]} total"
        puts "    ğŸ“… Latest release: #{cargo_info[:release_date] || 'unknown'}"
      end

    when 'npm'
      pkg = project['name']
      puts "  Querying npm registry for: #{pkg}"
      npm_info = fetch_npm_info(pkg)
      if npm_info
        project['description']   ||= npm_info[:description]
        project['release_date']    = npm_info[:release_date]
        project['minimum_version']||= npm_info[:node_version]
        if forges.none? { |f| f['type'] == 'GitHub' } && npm_info[:repository]
          url = npm_info[:repository].sub(/\.git$/, '')
          if url.include?('github.com')
            owner = url.match(%r{github\.com/([^/]+)/})&.send(:[], 1)
            forges << { 'type' => 'GitHub', 'url' => url, 'owner' => owner }
            project['forges'] = forges
          end
        end
        puts "    ğŸ“… Latest release: #{npm_info[:release_date] || 'unknown'}"
      end

    when 'pypi'
      pkg = project['name']
      puts "  Querying PyPI for: #{pkg}"
      pypi_info = fetch_pypi_info(pkg)
      if pypi_info
        project['description']    ||= pypi_info[:description]
        project['release_date']     = pypi_info[:release_date]
        project['minimum_version'] ||= pypi_info[:python_version]
        if forges.none? { |f| f['type'] == 'GitHub' } && pypi_info[:repository]
          url = pypi_info[:repository].sub(/\.git$/, '')
          if url.include?('github.com')
            owner = url.match(%r{github\.com/([^/]+)/})&.send(:[], 1)
            forges << { 'type' => 'GitHub', 'url' => url, 'owner' => owner }
            project['forges'] = forges
          end
        end
        puts "    ğŸ“… Latest release: #{pypi_info[:release_date] || 'unknown'}"
      end

    when 'go'
      pkg = project['name']
      puts "  Querying Go module proxy for: #{pkg}"
      go_info = fetch_go_info(pkg)
      if go_info
        project['release_date']    = go_info[:release_date]
        project['minimum_version']||= go_info[:go_version]
        puts "    ğŸ“… Latest release: #{go_info[:release_date] || 'unknown'}"
      end
    end

    # GitHub info (stars, last commit, status, first commit)
    github_forge = project['forges'].find { |f| f['type'] == 'GitHub' }
    if github_forge
      puts "  Querying GitHub for: #{github_forge['url']}"
      begin
        github_info = fetch_github_info(github_forge['url'])
        project['github_stars']   = github_info[:stars]
        project['last_commit_on'] = github_info[:last_commit]
        project['status']         = github_info[:archived] ? 'archived' : 'active'
        puts "    â­ Stars: #{github_info[:stars]}"
        puts "    ğŸ”¨ Last commit: #{github_info[:last_commit] || 'unknown'}"

        repo_path = extract_repo_path(github_forge['url'])
        if repo_path
          first_commit = fetch_first_commit(repo_path)
          if first_commit
            project['first_commit']    = first_commit[:url]
            project['first_commit_on'] = first_commit[:date]
            puts "    ğŸ First commit: #{first_commit[:date] || 'unknown'}"
          end
        end
      rescue => e
        puts "    âš ï¸  GitHub fetch failed: #{e.message}"
        project['github_stars'] = 0
        project['status']       = 'active'
      end
    else
      project['github_stars'] = 0
      project['status']       = 'active'
    end

    # Defaults for anything still nil
    project['first_commit_on'] ||= project['release_date']
    project['status']          ||= 'active'

    # â”€â”€ Review and confirm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    puts ""
    puts "="*80
    puts "ğŸ“‹ REVIEW â€” project entry to be added:"
    puts "="*80
    puts project.reject { |_, v| v.nil? }.to_yaml.gsub(/^---\n?/, '')
    puts "="*80
    puts ""

    unless confirm("ğŸ’¾ Add this project to projects.yml?", default: true)
      puts "Aborted â€” nothing was saved."
      exit 0
    end

    @projects << project
    @projects_dev << project.dup

    save_yaml(PROJECTS_FILE, @projects)
    puts "  ğŸ’¾ Saved to projects.yml"
    save_yaml(PROJECTS_DEV_FILE, @projects_dev) if @projects_dev
    puts "  ğŸ”„ Synced to projects_dev.yml"
    puts "\nâœ… Project '#{project['name']}' added successfully."
  end

  # â”€â”€ Multi-ecosystem package info fetchers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  def fetch_cargo_info(crate_name)
    data = api_request("https://crates.io/api/v1/crates/#{crate_name}")
    return nil unless data && data['crate']

    c = data['crate']
    newest_version = data.dig('versions')&.find { |v| !v['yanked'] }

    {
      description:      c['description'],
      total_downloads:  c['downloads'],
      release_downloads: newest_version&.dig('downloads'),
      release_date:     newest_version ? Date.parse(newest_version['updated_at']).strftime('%Y/%m/%d') : nil,
      rust_version:     newest_version&.dig('rust_version'),
      repository:       c['repository'],
    }
  rescue => e
    puts "    âš ï¸  crates.io fetch failed: #{e.message}"
    nil
  end

  def fetch_npm_info(pkg_name)
    data = api_request("https://registry.npmjs.org/#{URI.encode_www_form_component(pkg_name)}/latest")
    return nil unless data

    repo = data.dig('repository', 'url') || ''
    repo = repo.sub(/^git\+/, '').sub(/^git:\/\//, 'https://').sub(/\.git$/, '')

    node_ver = data.dig('engines', 'node')
    node_ver = node_ver.match(/(\d+\.\d*)/)&.send(:[], 1) if node_ver

    {
      description:  data['description'],
      release_date: nil, # latest endpoint doesn't include publish time; dist-tags/time needs separate call
      node_version: node_ver,
      repository:   repo.include?('github.com') ? repo : nil,
    }
  rescue => e
    puts "    âš ï¸  npm fetch failed: #{e.message}"
    nil
  end

  def fetch_pypi_info(pkg_name)
    data = api_request("https://pypi.org/pypi/#{pkg_name}/json")
    return nil unless data

    info    = data['info'] || {}
    releases = data['releases'] || {}
    # Find the latest non-dev release date
    release_date = nil
    latest_ver = info['version']
    if latest_ver && releases[latest_ver]
      files = releases[latest_ver].reject { |f| f['yanked'] }
      upload_time = files.first&.dig('upload_time')
      release_date = Date.parse(upload_time).strftime('%Y/%m/%d') if upload_time
    end

    python_ver = info['requires_python']
    python_ver = python_ver.match(/(\d+\.\d*)/)&.send(:[], 1) if python_ver

    repo = [info['project_urls']&.dig('Source'), info['home_page']].compact.find { |u| u.include?('github.com') }

    {
      description:    info['summary'],
      release_date:   release_date,
      python_version: python_ver,
      repository:     repo,
    }
  rescue => e
    puts "    âš ï¸  PyPI fetch failed: #{e.message}"
    nil
  end

  def fetch_go_info(module_path)
    # Go module proxy: https://proxy.golang.org/<module>/@latest
    encoded = module_path.gsub(/([A-Z])/) { |m| "!#{m.downcase}" }
    data = api_request("https://proxy.golang.org/#{encoded}/@latest")
    return nil unless data

    release_date = data['Time'] ? Date.parse(data['Time']).strftime('%Y/%m/%d') : nil

    # go.dev/ref/mod doesn't expose min Go version via proxy; try pkg.go.dev API
    go_version = nil

    {
      release_date: release_date,
      go_version:   go_version,
      version:      data['Version'],
    }
  rescue => e
    puts "    âš ï¸  Go proxy fetch failed: #{e.message}"
    nil
  end

  # Prompt helper that supports a pre-supplied value (skips interactive prompt).
  def ask(prompt, default: nil)
    if @auto_confirm && !default.nil?
      val = default.to_s.empty? ? nil : default
      display = val || '(empty)'
      puts "#{prompt}: #{display} [auto]"
      return val
    end

    display_default = default.nil? || default.to_s.empty? ? '' : " [#{default}]"
    print "#{prompt}#{display_default}: "
    $stdout.flush
    input = $stdin.gets&.chomp
    return default if input.nil? || input.strip.empty?
    input.strip
  end

  # ============================================================================
  # END ADD PROJECT
  # ============================================================================

  def fetch_user_rubygems(handle)
    api_url = "https://rubygems.org/api/v1/owners/#{handle}/gems.json"

    puts "  Fetching gems from: #{api_url}"
    data = api_request(api_url)

    return [] unless data && data.is_a?(Array)

    # The API returns an array of gem objects with 'name' field
    data.map { |gem| gem['name'] }.compact
  rescue => e
    error_msg = "Failed to fetch RubyGems for #{handle}: #{e.message}"
    @errors << error_msg
    puts "  âŒ #{error_msg}"
    []
  end

  def build_project_from_rubygem(gem_name)
    # Fetch gem metadata
    gem_info = fetch_rubygems_info(gem_name)
    api_url = "https://rubygems.org/api/v1/gems/#{gem_name}.json"
    gem_data = api_request(api_url)

    unless gem_data
      raise "Failed to fetch gem metadata"
    end

    # Extract key information
    description = gem_data['info'] || gem_data['summary'] || "Ruby gem: #{gem_name}"
    homepage_uri = gem_data['homepage_uri'] || ""
    source_code_uri = gem_data['source_code_uri'] || gem_data['source_code'] || ""

    # Try to determine GitHub URL
    github_url = nil
    github_owner = nil

    # Check various URI fields for GitHub
    [source_code_uri, homepage_uri, gem_data['project_uri']].compact.each do |uri|
      if uri.include?('github.com')
        github_url = uri.sub(/\.git$/, '').sub(%r{/tree/.*}, '').sub(%r{/blob/.*}, '')
        if match = github_url.match(%r{github\.com/([^/]+)/})
          github_owner = match[1]
        end
        break
      end
    end

    # Build forges array
    forges = []
    if github_url
      forges << {
        'type' => 'GitHub',
        'url' => github_url,
        'owner' => github_owner
      }
    end

    # Get release date
    release_date = fetch_rubygems_release_date(gem_name)

    # Determine minimum Ruby version
    required_ruby_version = gem_data['required_ruby_version'] || '>= 0'
    min_version = extract_minimum_version(required_ruby_version)

    # Build the project hash
    project = {
      'name' => gem_name,
      'description' => description,
      'language' => 'Ruby',
      'ecosystem' => 'rubygems',
      'minimum_version' => min_version,
      'role' => 'author', # Assume author since it's owned by the user
      'first_commit_on' => release_date, # Use first release date as placeholder
      'first_commit' => nil, # Will need to be filled manually or via GitHub API
      'funding_sites' => [
        { 'type' => 'OpenCollective', 'url' => 'https://opencollective.com/galtzo-floss' },
        { 'type' => 'Liberapay', 'url' => 'https://liberapay.com/pboling' }
      ],
      'forges' => forges,
      'tags' => determine_tags_from_gem(gem_data),
      'docs_site' => gem_data['documentation_uri'] || nil
    }

    # Add download stats if available
    if gem_info
      project['total_downloads'] = gem_info[:total_downloads]
      project['daily_downloads'] = gem_info[:daily_downloads]
      project['release_downloads'] = gem_info[:release_downloads]
    end

    project['release_date'] = release_date

    # Fetch GitHub info if available
    if github_url
      begin
        github_info = fetch_github_info(github_url)
        project['github_stars'] = github_info[:stars]
        project['last_commit_on'] = github_info[:last_commit]
        project['status'] = github_info[:archived] ? 'archived' : 'active'

        # Try to get first commit info
        repo_path = extract_repo_path(github_url)
        if repo_path
          first_commit = fetch_first_commit(repo_path)
          project['first_commit'] = first_commit[:url] if first_commit
          project['first_commit_on'] = first_commit[:date] if first_commit
        end
      rescue => e
        puts "    âš ï¸  Could not fetch GitHub info: #{e.message}"
        project['github_stars'] = 0
        project['status'] = 'active'
      end
    else
      puts "    âš ï¸  No GitHub URL found - will need manual configuration"
      project['github_stars'] = 0
      project['status'] = 'active'
    end

    project
  end

  def fetch_first_commit(repo_path)
    # Fetch the first commit using the API
    api_url = "https://api.github.com/repos/#{repo_path}/commits?per_page=1&sha=HEAD"

    # We need to paginate backwards to find the first commit
    # This is a simplified approach - we'll get the last page
    response_data = github_api_request_with_headers(api_url)

    return nil unless response_data[:data] && response_data[:data].is_a?(Array) && response_data[:data].any?

    # Check if there are more pages by looking at Link header
    last_page_url = response_data[:last_page_url]

    if last_page_url
      # Fetch the last page (which contains the first commit)
      last_page_data = github_api_request(last_page_url)
      first_commit = last_page_data.last if last_page_data.is_a?(Array)
    else
      # Only one page, so the last commit is the first
      first_commit = response_data[:data].last
    end

    if first_commit
      commit_date = first_commit.dig('commit', 'committer', 'date')
      {
        url: first_commit['html_url'],
        date: commit_date ? Date.parse(commit_date).strftime('%Y/%m/%d') : nil
      }
    else
      nil
    end
  rescue => e
    puts "    âš ï¸  Could not fetch first commit: #{e.message}"
    nil
  end

  def github_api_request_with_headers(url)
    uri = URI(url)
    request = Net::HTTP::Get.new(uri)
    request['Accept'] = 'application/vnd.github.v3+json'
    request['Authorization'] = "token #{GITHUB_TOKEN}" if GITHUB_TOKEN
    request['User-Agent'] = 'Galtzo-Project-Updater'

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end

    if response.code.to_i == 404
      return { data: nil, last_page_url: nil }
    elsif response.code.to_i != 200
      raise "GitHub API error: #{response.code} - #{response.body[0..200]}"
    end

    # Parse Link header to find last page
    link_header = response['Link']
    last_page_url = nil

    if link_header
      # Extract last page URL from Link header
      # Format: <url>; rel="last"
      if match = link_header.match(/<([^>]+)>;\s*rel="last"/)
        last_page_url = match[1]
      end
    end

    {
      data: JSON.parse(response.body),
      last_page_url: last_page_url
    }
  end

  def extract_minimum_version(version_string)
    # Parse version string like ">= 2.7.0" or "~> 3.0"
    # Return just the major.minor version
    if match = version_string.match(/(\d+\.\d+)/)
      match[1]
    else
      '2.7' # Default to a reasonable version
    end
  end

  def determine_tags_from_gem(gem_data)
    tags = []

    # Check description and summary for common keywords
    text = "#{gem_data['info']} #{gem_data['summary']}".downcase

    # Common tag patterns
    tags << 'rails' if text.include?('rails') || text.include?('activerecord')
    tags << 'activerecord' if text.include?('activerecord')
    tags << 'rspec' if text.include?('rspec')
    tags << 'testing' if text.include?('test') || text.include?('spec')
    tags << 'api' if text.include?('api')
    tags << 'cli' if text.include?('cli') || text.include?('command line')
    tags << 'security' if text.include?('security') || text.include?('auth')
    tags << 'performance' if text.include?('performance') || text.include?('optimization')
    tags << 'debugging' if text.include?('debug') || text.include?('logging')

    # At least return a generic 'ruby' tag
    tags << 'ruby' if tags.empty?

    tags.uniq.sort
  end

  def update_single_field(project, field)
    forges = project['forges'] || []
    github_forge = forges.find { |f| f['type'] == 'GitHub' }
    gitlab_forge = forges.find { |f| f['type'] == 'GitLab' }
    codeberg_forge = forges.find { |f| f['type'] == 'Codeberg' }

    case field
    when 'github_stars'
      raise "Missing GitHub forge for project: #{project['name']}" unless github_forge
      github_info = fetch_github_info(github_forge['url'])
      project['github_stars'] = github_info[:stars]
      puts "  â­ GitHub stars: #{github_info[:stars]}"

    when 'gitlab_stars'
      if gitlab_forge
        gitlab_stars = fetch_gitlab_stars(gitlab_forge['url'])
        project['gitlab_stars'] = gitlab_stars
        puts "  â­ GitLab stars: #{gitlab_stars}"
      else
        puts "  â­ï¸  No GitLab forge for this project"
      end

    when 'codeberg_stars'
      if codeberg_forge
        codeberg_stars = fetch_codeberg_stars(codeberg_forge['url'])
        project['codeberg_stars'] = codeberg_stars
        puts "  â­ Codeberg stars: #{codeberg_stars}"
      else
        puts "  â­ï¸  No Codeberg forge for this project"
      end

    when 'total_downloads', 'daily_downloads', 'release_downloads'
      if project['language'] == 'Ruby' && project['ecosystem'] == 'rubygems'
        gem_name = project['name']
        gem_info = fetch_rubygems_info(gem_name)
        if gem_info
          project['total_downloads'] = gem_info[:total_downloads]
          project['daily_downloads'] = gem_info[:daily_downloads]
          project['release_downloads'] = gem_info[:release_downloads]
          puts "  ğŸ“¦ #{field}: #{gem_info[field.to_sym]}"
        end
      else
        puts "  â­ï¸  Not a RubyGem"
      end

    when 'release_date'
      if project['language'] == 'Ruby' && project['ecosystem'] == 'rubygems'
        gem_name = project['name']
        release_date = fetch_rubygems_release_date(gem_name)
        project['release_date'] = release_date
        puts "  ğŸ“… Release date (RubyGems): #{release_date}"
      else
        raise "Missing GitHub forge for project: #{project['name']}" unless github_forge
        release_date = fetch_github_release_date(github_forge['url'])
        project['release_date'] = release_date
        puts "  ğŸ“… Release date (GitHub): #{release_date || 'N/A'}"
      end

    when 'last_commit_on'
      raise "Missing GitHub forge for project: #{project['name']}" unless github_forge
      github_info = fetch_github_info(github_forge['url'])
      last_commit = github_info[:last_commit]
      project['last_commit_on'] = last_commit
      puts "  ğŸ”¨ Last commit: #{last_commit || 'N/A'}"

    when 'status'
      raise "Missing GitHub forge for project: #{project['name']}" unless github_forge
      github_info = fetch_github_info(github_forge['url'])
      last_commit = github_info[:last_commit]

      if github_info[:archived]
        project['status'] = 'archived'
        puts "  ğŸ“¦ Status: archived"
      elsif last_commit.nil? || days_since(last_commit) > 365
        project['status'] = 'stale'
        puts "  âš ï¸  Status: stale"
      else
        project['status'] = 'active'
        puts "  âœ… Status: active"
      end
    end
  end

  def update_project(project)
    # Validate theme configuration first
    validate_project_theme(project)

    forges = project['forges'] || []
    github_forge = forges.find { |f| f['type'] == 'GitHub' }
    gitlab_forge = forges.find { |f| f['type'] == 'GitLab' }
    codeberg_forge = forges.find { |f| f['type'] == 'Codeberg' }

    # Step 1: GitHub stars (required)
    raise "Missing GitHub forge for project: #{project['name']}" unless github_forge

    github_info = fetch_github_info(github_forge['url'])
    project['github_stars'] = github_info[:stars]
    puts "  â­ GitHub stars: #{github_info[:stars]}"

    # Step 2: GitLab stars (if present)
    if gitlab_forge
      gitlab_stars = fetch_gitlab_stars(gitlab_forge['url'])
      project['gitlab_stars'] = gitlab_stars
      puts "  â­ GitLab stars: #{gitlab_stars}"
    end

    # Step 3: Codeberg stars (if present)
    if codeberg_forge
      codeberg_stars = fetch_codeberg_stars(codeberg_forge['url'])
      project['codeberg_stars'] = codeberg_stars
      puts "  â­ Codeberg stars: #{codeberg_stars}"
    end

    # Steps 4-6: RubyGems download statistics (for Ruby gems only)
    if project['language'] == 'Ruby' && project['ecosystem'] == 'rubygems'
      gem_name = project['name']
      gem_info = fetch_rubygems_info(gem_name)

      if gem_info
        project['total_downloads'] = gem_info[:total_downloads]
        project['daily_downloads'] = gem_info[:daily_downloads]
        project['release_downloads'] = gem_info[:release_downloads]

        puts "  ğŸ“¦ Total downloads: #{gem_info[:total_downloads]}"
        if gem_info[:daily_downloads]
          puts "  ğŸ“Š Daily downloads: #{gem_info[:daily_downloads]}"
        else
          puts "  ğŸ“Š Daily downloads: N/A (not available via public API)"
        end
        puts "  ğŸ“¥ Release downloads: #{gem_info[:release_downloads]}"
      end
    end

    # Step 7: Latest release date
    if project['language'] == 'Ruby' && project['ecosystem'] == 'rubygems'
      # Prefer RubyGems release date
      gem_name = project['name']
      release_date = fetch_rubygems_release_date(gem_name)
      project['release_date'] = release_date
      puts "  ğŸ“… Release date (RubyGems): #{release_date}"
    else
      # Use GitHub release date
      release_date = fetch_github_release_date(github_forge['url'])
      project['release_date'] = release_date
      puts "  ğŸ“… Release date (GitHub): #{release_date || 'N/A'}"
    end

    # Step 8: Last commit date
    last_commit = github_info[:last_commit]
    project['last_commit_on'] = last_commit
    puts "  ğŸ”¨ Last commit: #{last_commit || 'N/A'}"

    # Step 9-10: Determine status (archived, stale, or active)
    if github_info[:archived]
      project['status'] = 'archived'
      puts "  ğŸ“¦ Status: archived"
    elsif last_commit.nil? || days_since(last_commit) > 365
      project['status'] = 'stale'
      puts "  âš ï¸  Status: stale (#{days_since(last_commit)} days since last commit)"
    else
      project['status'] = 'active'
      puts "  âœ… Status: active"
    end
  end

  def sync_to_dev(project)

    dev_project = @projects_dev.find { |p| p['name'] == project['name'] }
    return unless dev_project

    # Sync the computed fields
    sync_fields = %w[
      github_stars gitlab_stars codeberg_stars
      total_downloads daily_downloads release_downloads
      release_date last_commit_on status last_scrape_at
    ]

    sync_fields.each do |field|
      dev_project[field] = project[field] if project.key?(field)
    end

    puts "  ğŸ”„ Synced to projects_dev.yml"
  end

  def recently_scraped?(project)
    return false unless project['last_scrape_at']

    begin
      last_scrape = Time.parse(project['last_scrape_at'])
      hours_ago = (Time.now.utc - last_scrape) / 3600
      hours_ago < SCRAPE_THRESHOLD_HOURS
    rescue
      false
    end
  end

  def time_ago(timestamp)
    return "unknown time" unless timestamp

    begin
      last_scrape = Time.parse(timestamp)
      hours_ago = ((Time.now.utc - last_scrape) / 3600).round(1)

      if hours_ago < 1
        "#{(hours_ago * 60).round} minutes ago"
      else
        "#{hours_ago} hours ago"
      end
    rescue
      "unknown time"
    end
  end

  def fetch_github_info(url)
    repo_path = extract_repo_path(url)
    api_url = "https://api.github.com/repos/#{repo_path}"

    data = github_api_request(api_url)

    # Fetch last commit date
    commits_url = "https://api.github.com/repos/#{repo_path}/commits"
    commits_data = github_api_request(commits_url)
    last_commit = nil
    if commits_data.is_a?(Array) && commits_data.any?
      commit_date = commits_data.first.dig('commit', 'committer', 'date')
      last_commit = Date.parse(commit_date).strftime('%Y/%m/%d') if commit_date
    end

    {
      stars: data['stargazers_count'] || 0,
      archived: data['archived'] || false,
      last_commit: last_commit
    }
  rescue => e
    error_msg = "Failed to fetch GitHub info: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    { stars: 0, archived: false, last_commit: nil }
  end

  def fetch_github_release_date(url)
    repo_path = extract_repo_path(url)
    api_url = "https://api.github.com/repos/#{repo_path}/releases/latest"

    data = github_api_request(api_url)
    return nil unless data && data['published_at']

    Date.parse(data['published_at']).strftime('%Y/%m/%d')
  rescue => e
    error_msg = "Failed to fetch GitHub release date from #{url}: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    nil
  end

  def fetch_gitlab_stars(url)
    # Extract project path from GitLab URL
    # Format: https://gitlab.com/owner/project
    path = url.gsub('https://gitlab.com/', '')
    encoded_path = URI.encode_www_form_component(path)
    api_url = "https://gitlab.com/api/v4/projects/#{encoded_path}"

    data = gitlab_api_request(api_url)
    return 0 unless data

    data['star_count'] || 0
  rescue => e
    error_msg = "Failed to fetch GitLab stars from #{url}: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    0
  end

  def fetch_codeberg_stars(url)
    # Codeberg uses Gitea API
    # Format: https://codeberg.org/owner/project
    match = url.match(%r{codeberg\.org/([^/]+)/([^/]+)})
    return 0 unless match

    owner, repo = match[1], match[2]
    api_url = "https://codeberg.org/api/v1/repos/#{owner}/#{repo}"

    data = api_request(api_url)
    return 0 unless data

    data['stars_count'] || 0
  rescue => e
    error_msg = "Failed to fetch Codeberg stars from #{url}: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    0
  end

  def fetch_rubygems_info(gem_name)
    # Fetch gem stats - this includes all download data available via public API
    api_url = "https://rubygems.org/api/v1/gems/#{gem_name}.json"
    data = api_request(api_url)

    return nil unless data

    total_downloads = data['downloads'] || 0
    version_downloads = data['version_downloads'] || 0

    # Note: RubyGems public API does not provide daily/weekly/monthly download statistics
    # We'll set this to nil to indicate it's not available
    daily_downloads = nil

    {
      total_downloads: total_downloads,
      daily_downloads: daily_downloads,
      release_downloads: version_downloads
    }
  rescue => e
    error_msg = "Failed to fetch RubyGems info for #{gem_name}: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    nil
  end

  def fetch_rubygems_release_date(gem_name)
    # The versions endpoint returns an array of all versions, with the latest first
    api_url = "https://rubygems.org/api/v1/versions/#{gem_name}.json"
    data = api_request(api_url)

    return nil unless data && data.is_a?(Array) && data.any?

    # Get the first non-prerelease version
    latest_version = data.find { |v| !v['prerelease'] }
    return nil unless latest_version && latest_version['created_at']

    Date.parse(latest_version['created_at']).strftime('%Y/%m/%d')
  rescue => e
    error_msg = "Failed to fetch RubyGems release date for #{gem_name}: #{e.message}"
    @errors << error_msg unless @errors.include?(error_msg)
    puts "    âš ï¸  #{error_msg}"
    nil
  end

  def github_api_request(url)
    uri = URI(url)
    request = Net::HTTP::Get.new(uri)
    request['Accept'] = 'application/vnd.github.v3+json'
    request['Authorization'] = "token #{GITHUB_TOKEN}" if GITHUB_TOKEN
    request['User-Agent'] = 'Galtzo-Project-Updater'

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end

    if response.code.to_i == 404
      return nil
    elsif response.code.to_i != 200
      raise "GitHub API error: #{response.code} - #{response.body[0..200]}"
    end

    JSON.parse(response.body)
  end

  def gitlab_api_request(url)
    uri = URI(url)
    request = Net::HTTP::Get.new(uri)
    request['Authorization'] = "Bearer #{GITLAB_TOKEN}" if GITLAB_TOKEN
    request['User-Agent'] = 'Galtzo-Project-Updater'

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end

    if response.code.to_i == 404
      return nil
    elsif response.code.to_i != 200
      raise "GitLab API error: #{response.code} - #{response.body[0..200]}"
    end

    JSON.parse(response.body)
  end

  def api_request(url)
    uri = URI(url)
    request = Net::HTTP::Get.new(uri)
    request['User-Agent'] = 'Galtzo-Project-Updater'

    response = Net::HTTP.start(uri.hostname, uri.port, use_ssl: true) do |http|
      http.request(request)
    end

    if response.code.to_i == 404
      return nil
    elsif response.code.to_i != 200
      raise "API error: #{response.code} - #{response.body[0..200]}"
    end

    JSON.parse(response.body)
  end

  def extract_repo_path(url)
    # Extract owner/repo from GitHub URL
    # Handles: https://github.com/owner/repo or https://github.com/owner/repo.git
    match = url.match(%r{github\.com[/:]([^/]+)/([^/\.]+)})
    return nil unless match
    "#{match[1]}/#{match[2]}"
  end

  def days_since(date_string)
    return Float::INFINITY if date_string.nil?

    date = Date.parse(date_string.gsub('/', '-'))
    (Date.today - date).to_i
  rescue
    Float::INFINITY
  end

  def load_yaml(file_path)
    YAML.load_file(file_path) || []
  end

  def extract_yaml_header(file_path)
    return "" unless File.exist?(file_path)

    header_lines = []
    in_header = false

    File.readlines(file_path).each do |line|
      # Start capturing after the --- document marker
      if line.strip == '---'
        in_header = true
        next
      end

      # Stop when we hit the first non-comment, non-empty line (start of data)
      if in_header
        if line.strip.start_with?('#') || line.strip.empty?
          header_lines << line
        else
          # We've reached the data section
          break
        end
      end
    end

    # Return the header with a trailing newline if we found comments
    header_lines.empty? ? "" : header_lines.join
  end

  def save_yaml(file_path, data)
    # Guard: minimum_version must always be a String so YAML round-trips cleanly
    # and index.html's .sort on version arrays never mixes Float with String.
    data.each do |entry|
      next unless entry.is_a?(Hash) && entry.key?('minimum_version')
      v = entry['minimum_version']
      entry['minimum_version'] = v.to_s unless v.nil? || v.is_a?(String)
    end

    yaml_content = YAML.dump(data)

    # Determine which header to use based on the file path
    header = if file_path == PROJECTS_DEV_FILE
      @projects_dev_header
    elsif file_path == PROJECTS_FILE
      @projects_header
    else
      ""
    end

    # Combine header with YAML content
    if header && !header.empty?
      # The YAML.dump already includes '---' at the start
      # We need to insert the header after the '---' line
      yaml_lines = yaml_content.lines
      if yaml_lines.first&.strip == '---'
        final_content = yaml_lines.first + header + yaml_lines[1..-1].join
      else
        final_content = "---\n" + header + yaml_content
      end
    else
      final_content = yaml_content
    end

    File.write(file_path, final_content)
    puts "\nğŸ’¾ Saved: #{file_path}"
  end

  # ============================================================================
  # THEME VALIDATION METHODS
  # ============================================================================

  # Validate theme field and theme-specific configuration
  def validate_project_theme(project)
    theme = project['theme']

    # Theme is optional
    return true if theme.nil?

    valid_themes = %w[adopt-me update-me avoid-me family holiday]

    unless valid_themes.include?(theme)
      raise "Invalid theme '#{theme}' for project '#{project['name']}'. Valid themes: #{valid_themes.join(', ')}"
    end

    # Validate theme-specific fields
    case theme
    when 'family'
      validate_family_theme(project)
    when 'holiday'
      validate_holiday_theme(project)
    when 'adopt-me'
      validate_adopt_me_theme(project)
    when 'update-me'
      validate_update_me_theme(project)
    when 'avoid-me'
      validate_avoid_me_theme(project)
    end

    true
  end

  def validate_family_theme(project)
    required_fields = %w[family_id family_position]
    missing_fields = required_fields.select { |field| project[field].nil? }

    if missing_fields.any?
      raise "Family theme requires fields: #{missing_fields.join(', ')} for project '#{project['name']}'"
    end

    unless project['family_position'].is_a?(Integer) && project['family_position'] > 0
      raise "family_position must be a positive integer for project '#{project['name']}'"
    end

    true
  end

  def validate_holiday_theme(project)
    valid_types = %w[christmas halloween newyear birthday celebration]
    holiday_type = project['holiday_type']

    if holiday_type.nil?
      raise "Holiday theme requires 'holiday_type' field for project '#{project['name']}'"
    end

    unless valid_types.include?(holiday_type)
      raise "Invalid holiday_type '#{holiday_type}' for project '#{project['name']}'. Valid types: #{valid_types.join(', ')}"
    end

    # Validate date format if provided
    if project['holiday_date_start']
      begin
        Date.parse(project['holiday_date_start'])
      rescue
        raise "Invalid holiday_date_start format for project '#{project['name']}'. Use YYYY-MM-DD"
      end
    end

    if project['holiday_date_end']
      begin
        Date.parse(project['holiday_date_end'])
      rescue
        raise "Invalid holiday_date_end format for project '#{project['name']}'. Use YYYY-MM-DD"
      end
    end

    true
  end

  def validate_adopt_me_theme(project)
    # adoption_url is optional, no required fields
    if project['adoption_url'] && !project['adoption_url'].start_with?('http')
      raise "adoption_url must be a valid URL for project '#{project['name']}'"
    end
    true
  end

  def validate_update_me_theme(project)
    # stale_since validation
    if project['stale_since']
      begin
        Date.parse(project['stale_since'])
      rescue
        raise "Invalid stale_since format for project '#{project['name']}'. Use YYYY-MM-DD"
      end
    end

    # update_priority validation
    if project['update_priority']
      valid_priorities = %w[low medium high]
      unless valid_priorities.include?(project['update_priority'])
        raise "Invalid update_priority '#{project['update_priority']}' for project '#{project['name']}'. Valid: #{valid_priorities.join(', ')}"
      end
    end

    true
  end

  def validate_avoid_me_theme(project)
    # archived should be boolean if present
    if project['archived'] && ![true, false].include?(project['archived'])
      raise "archived must be true or false for project '#{project['name']}'"
    end

    # replacement_url validation
    if project['replacement_url'] && !project['replacement_url'].start_with?('http')
      raise "replacement_url must be a valid URL for project '#{project['name']}'"
    end

    true
  end
end

# Run the updater
if __FILE__ == $0
  require 'optparse'

  options = {
    auto_confirm:     false,
    discover_rubygems: nil,   # nil = decide after parsing; true/false = explicit
  }
  add_project_opts = {}

  OptionParser.new do |op|
    op.banner = "Usage: #{$0} [OPTIONS] [SUBCOMMAND|FIELD]"

    op.separator ""
    op.separator "Fetches live stats for erefavery project in projects.yml from GitHub, GitLab,"
    op.separator "Codeberg, and RubyGems APIs."
    op.separator ""
    op.separator "When run with no subcommand or field, a RubyGems discovery pre-flight runs"
    op.separator "first: it queries RubyGems.org for every gem owned by RUBYGEMS_HANDLE,"
    op.separator "shows any that are missing from projects.yml, and asks whether to add them"
    op.separator "before the main update begins."
    op.separator ""
    op.separator "Subcommands:"
    op.separator "  add_project             Interactively add a single project to projects.yml."
    op.separator "                          Works for any language / ecosystem."
    op.separator ""
    op.separator "Surgical Update Fields (update one field across all projects):"
    ProjectUpdater::VALID_SURGICAL_FIELDS.each { |f| op.separator "  #{f}" }
    op.separator ""
    op.separator "Environment Variables:"
    op.separator "  GITHUB_TOKEN            Raises GitHub API rate limit from 60 to 5,000 req/hr"
    op.separator "  GITLAB_TOKEN            Authenticates GitLab API requests"
    op.separator "  RUBYGEMS_HANDLE         Your RubyGems username â€” required for gem discovery"
    op.separator ""
    op.separator "Examples:"
    op.separator "  #{$0}                              # Full update + gem discovery (interactive)"
    op.separator "  #{$0} -y                           # Full update + gem discovery (non-interactive)"
    op.separator "  #{$0} --no-discover                # Full update, skip gem discovery"
    op.separator "  #{$0} release_date                 # Surgical: update only release_date"
    op.separator "  #{$0} github_stars                 # Surgical: update only github_stars"
    op.separator "  #{$0} -y release_date              # Surgical update, non-interactive"
    op.separator "  #{$0} add_project                  # Interactively add a project"
    op.separator "  #{$0} add_project --name my-gem --ecosystem rubygems --github-url https://github.com/org/repo"
    op.separator ""
    op.separator "Options:"

    op.on("-y", "--no-tty", "Auto-accept all prompts (for CI / cron)") do
      options[:auto_confirm] = true
    end

    op.on("--no-discover", "Skip the RubyGems discovery pre-flight") do
      options[:discover_rubygems] = false
    end

    op.separator ""
    op.separator "add_project options (all optional â€” omitted values are prompted interactively):"

    op.on("--name NAME", "Project / package name") do |v|
      add_project_opts[:name] = v
    end

    op.on("--ecosystem ECO", "Package ecosystem: rubygems, cargo, npm, pypi, go, none") do |v|
      add_project_opts[:ecosystem] = v
    end

    op.on("--language LANG", "Primary language") do |v|
      add_project_opts[:language] = v
    end

    op.on("--role ROLE", "author | contributor | maintainer  (default: contributor)") do |v|
      add_project_opts[:role] = v
    end

    op.on("--github-url URL", "GitHub repository URL") do |v|
      add_project_opts[:github_url] = v
    end

    op.on("--gitlab-url URL", "GitLab repository URL") do |v|
      add_project_opts[:gitlab_url] = v
    end

    op.on("--codeberg-url URL", "Codeberg repository URL") do |v|
      add_project_opts[:codeberg_url] = v
    end

    op.on("--description TEXT", "Short description (HTML allowed)") do |v|
      add_project_opts[:description] = v
    end

    op.on("--minimum-version VER", "Minimum runtime version") do |v|
      add_project_opts[:minimum_version] = v
    end

    op.on("--tags TAG1,TAG2", "Comma-separated tags") do |v|
      add_project_opts[:tags] = v
    end

    op.on("--funding-sites SPEC",
          "Pre-set funding sites; use 'none' for empty, or 'TYPE1:URL1,TYPE2:URL2'") do |v|
      add_project_opts[:funding_sites] = v
    end

    op.on("-h", "--help", "Show this help message") do
      puts op
      exit 0
    end
  end.parse!

  # Remaining ARGV after parse! holds an optional subcommand or surgical field
  remainder = ARGV.first

  subcommand     = remainder == 'add_project' ? 'add_project' : nil
  surgical_field = (remainder && remainder != 'add_project') ? remainder : nil

  # Discovery is on by default ONLY for a bare full update (no subcommand, no
  # surgical field). When the user is doing something more targeted they don't
  # want the pre-flight slowing them down unless they asked for it explicitly.
  if options[:discover_rubygems].nil?
    options[:discover_rubygems] = subcommand.nil? && surgical_field.nil?
  end

  updater = ProjectUpdater.new(
    surgical_field:    surgical_field,
    discover_rubygems: options[:discover_rubygems],
    auto_confirm:      options[:auto_confirm],
  )

  case subcommand
  when 'add_project'
    updater.run_add_project(add_project_opts)
  else
    updater.run
  end
end
